{"title":"07 Robustness","markdown":{"yaml":{"title":"07 Robustness","subtitle":"Is TBTF Sadly Optimal by Design?","execute":{"enabled":true}},"headingText":"Out-of-sample Investment","containsRefs":false,"markdown":"\n\nWhile the previous section focused on the performance outcomes of the TBTF strategy, this section evaluates the **stability of those outcomes** under variation in core implementation parameters. We test whether the superior performance persists under changes in portfolio size, rebalancing frequency, weighting schemes, and look-back windows.\n\nRather than relying on a single optimized configuration, the TBTF strategy demonstrates **structural robustness across plausible alternatives**. This not only reinforces the credibility of the results, but also supports the **practical adaptability** of the approach for different institutional contexts.\n\nAll robustness tests are performed on the post-2010 period, with out-of-sample investment beginning on **2010-01-01**. The portfolio is trained using a 48-month rolling window (`in_sample=48M`) and evaluated through 2023-12-31.\n\n```{python}\n\nimport pandas as pd\nimport sqlite3\ncons = sqlite3.connect(database=\"../../tbtf.sqlite\")\n\ncrsp = pd.read_sql_query(\n  sql=\"SELECT * FROM crsp\",\n  con=cons,\n  parse_dates={\"date\"}\n)\n\n```\n\n```{python}\nimport sys\nimport os\n# 현재 경로 기준으로 상위 디렉토리로 경로 추가\nsys.path.append(os.path.abspath('../..'))\n\nimport tbtf\n\n\n# robust check 대상 파라미터 설정\ntop_ns = [5, 7, 10, 15, 20]\nrebalance_freqs = ['3M', '6M', '12M']\nweighting_methods = ['mean', 'quadratic', 'value', 'equal']\n\n# 기본 설정 정리\nin_end = '2009-12-31'         # in-sample 끝\nout_end = '2023-12-31'        # out-of-sample 끝\nin_sample_months = 48         # in-sample 기간 (예: 4년)\neta = 3                       # CRRA 계수\np = 0.01                      # Omega Ratio threshold\nstate = 10\n\n\nfrom joblib import Parallel, delayed\n\ndef run_single_backtest(method, n, freq):\n    result = tbtf.backtest_pipeline(\n        crsp=crsp,\n        in_end=in_end,\n        out_end=out_end,\n        in_sample_months=in_sample_months,\n        rebalance_freq=freq,\n        weighting_method=method,\n        top_n=n,\n        state=state,\n        eta=eta,\n        p=p\n    )\n    perf = result['performance']\n    perf.update({'n': n, 'rebalance_freq': freq, 'weighting_method': method})\n\n    turnover_df = result['turnover']\n    total_turnover = turnover_df.iloc[:-1]['turnover'].sum() if len(turnover_df) > 1 else np.nan\n\n    return perf, {'n': n, 'rebalance_freq': freq, 'weighting_method': method, 'total_turnover': total_turnover}\n```\n\n```{python}\n\nfrom itertools import product\n\nparam_grid = list(product(weighting_methods, top_ns, rebalance_freqs))\n\n# 병렬 실행\nresults = Parallel(n_jobs=-1)(delayed(run_single_backtest)(method, n, freq) for method, n, freq in param_grid)\n\n# Robustness check 결과 DataFrame 생성\nperformance_df = pd.DataFrame([r[0] for r in results])\nturnover_summary_df = pd.DataFrame([r[1] for r in results])\n```\n\n### Performance by Weighting Method\nWe begin by comparing the four weighting schemes: exponential (TBTF baseline), quadratic, value-weighted, and equal-weighted portfolios. The results show that TBTF's exponential weighting yields consistently superior risk-adjusted performance, particularly in terms of expected CRRA utility and downside-sensitive metrics like the Omega ratio.\n\n```{python}\n#| tbl-cap: \"Good Performance Metrics by Weighting Method\"\nmetrics = ['Expected CRRA', 'Annualized Return', 'Sharpe Ratio', 'Sortino Ratio', 'Calmar Ratio', 'Omega Ratio', 'Max Drawdown']\nperformance_df.groupby('weighting_method')[metrics].median().round(3).sort_values(by='Expected CRRA', ascending=False)\n\n```\n\n```{python}\n#| tbl-cap: \"Bad Performance Metric by Weighting Method\"\nmetrics = ['Annualized Volatility', 'Pearson Skewness', 'Excess Kurtosis']\nperformance_df.groupby('weighting_method')[metrics].median().round(3).sort_values(by='Annualized Volatility', ascending=True)\n```\n\n```{python}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n#sns.violinplot(data=performance_df, x='weighting_method', y='Annualized Volatility')\nsns.boxplot(data=performance_df, x='weighting_method', y='Sharpe Ratio')\nplt.title(\"Metric Distribution by Weighting Method\")\n```\n\nThese results suggest that nonlinear weighting schemes are critical to capturing the TBTF premium. Among them, the quadratic method slightly outperforms exponential weighting across most performance metrics, including the highest median Omega ratio (2.231) and lowest median drawdown (−13.2%). While exponential weighting reflects market power through CRRA-type concentration, the quadratic scheme appears to provide a more balanced tradeoff between concentration and diversification—delivering the best overall risk-adjusted profile among the tested methods.\n\n### Sensitivity to Asset Selection Size (`top_n`)\n\nNext, we vary the number of selected stocks, ranging from 5 to 20. The results clearly show that performance declines as top_n increases, confirming that capital concentration—not mere size exposure—is the key driver.\n\n```{python}\n#| tbl-cap: \"Sharpe Ratio by Weighting Method and Top-n\"\nperformance_df.pivot_table(\n    values='Sharpe Ratio',\n    index='weighting_method',\n    columns='n',\n    aggfunc='mean'\n)\n```\n\n```{python}\n#| tbl-cap: \"Expected CRRA Utility across Weighting Methods and Top-n\"\nperformance_df.pivot_table(\n    values='Expected CRRA',\n    index='weighting_method',\n    columns='n'\n).round(4)\n```\n\nVarying the number of selected stocks from 5 to 20 reveals a consistent pattern: risk-adjusted performance declines as the portfolio expands, regardless of weighting method. This is most clearly visible in the expected CRRA utility, where values decrease monotonically for all methods. For instance, under exponential weighting, median CRRA utility drops from 0.0175 at $n=5$ to 0.0125 at $n=20$—a 29% reduction. Similarly, the Sharpe ratio decreases from 0.6367 to 0.6026.\n\nThis pattern suggests that the TBTF premium is not a smooth function of size, but rather anchored at the extreme upper tail of the capital distribution. The diminishing returns from including more assets reinforce the structural logic of capital lock-in: only the very top firms consistently benefit from persistent investor flows, narrative insulation, and index-based reinforcement.\n\nInterestingly, quadratic weighting exhibits the most stable decay, maintaining higher CRRA utility at larger $n$ relative to exponential or value weighting. This may reflect its slightly more diversified nature, balancing concentration with convex adjustment. Equal weighting, by contrast, consistently underperforms across all $n$ values, underscoring the importance of incorporating size asymmetry into portfolio design.\n\n\n### Rebalancing Frequency and Turnover Tradeoff\n\nWe next examine the impact of rebalancing frequency—specifically, quarterly (`3M`), semiannual (`6M`), and annual (`12M`)—on risk-adjusted performance and underlying portfolio structure. As shown in the heatmap below, quarterly rebalancing tends to produce higher Sharpe ratios across most configurations, especially at smaller `n`. However, this benefit comes at the cost of substantially higher turnover, as discussed in below.\n\n```{python}\n#| fig-cap: \"Sharpe Ratio Heatmap (Top-n vs Rebalancing Frequency)\"\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# 원하는 순서로 정렬\nrebalance_order = ['3M', '6M', '12M']\nn_order = sorted(performance_df['n'].unique(), reverse=True)  # n=5,7,10,15,20 등 오름차순\n\n# Pivot and reorder\npivot_sharpe = (\n    performance_df.pivot_table(\n        values='Sharpe Ratio',\n        index='n',\n        columns='rebalance_freq'\n    )\n    .loc[n_order, rebalance_order]  # y축 (n), x축 (rebalance_freq) 순서 정렬\n    .round(2)\n)\n\n# Pivot을 위한 사용자 정의 함수\ndef best_weighting_by_sharpe(df):\n    idx = df.groupby(['n', 'rebalance_freq'])['Sharpe Ratio'].idxmax()\n    best_df = df.loc[idx, ['n', 'rebalance_freq', 'weighting_method']]\n    pivot = best_df.pivot(index='n', columns='rebalance_freq', values='weighting_method')\n\n    # 시각화-friendly 정렬\n    pivot = pivot.loc[sorted(pivot.index, reverse=True), ['3M', '6M', '12M']]\n    return pivot\n\nbest_weighting_pivot = best_weighting_by_sharpe(performance_df)\n\n# 결과 출력\n# display(best_weighting_pivot)\n\nplt.figure(figsize=(8, 5))\n# sns.heatmap(pivot_sharpe, annot=True, cmap=\"YlGnBu\", cbar_kws={'label': 'Sharpe Ratio'})\nsns.heatmap(\n    pivot_sharpe,  # 기존 numeric table\n    annot=best_weighting_pivot.values,  # 텍스트는 scheme 이름으로\n    fmt='',  # 숫자 포맷 아님\n    cmap=\"YlGnBu\",\n    cbar_kws={'label': 'Sharpe Ratio'}\n)\nplt.title(\"Best Weighting Method by Sharpe Ratio\")\nplt.xlabel(\"Rebalancing Frequency\")\nplt.ylabel(\"Number of Selected Assets (n)\")\nplt.tight_layout()\nplt.show()\n\n```\n\nBeyond performance, we investigate **portfolio stability across rebalancing intervals** using the correlation of portfolio weights between consecutive rebalancing periods. The results reveal distinct structural patterns:\n\n- Under **quarterly rebalancing (3M)**, the correlation of portfolio weights increases with `n`, rising from 0.95 at $n=5$ to nearly 1.00 at $n=20$. This reflects **high persistence** in capital allocation, especially when more firms are included.\n- In contrast, **semiannual rebalancing (6M)** exhibits a declining pattern: correlation decreases from 0.79 at $n=5$ to 0.75 at $n=20$, suggesting **greater portfolio reshuffling** under moderate rebalancing horizons.\n- For **annual rebalancing (12M)**, the relationship is **non-monotonic**, forming an inverted U-shape. Correlation peaks at $n=7$ (0.17), but falls off before and after—indicating that at longer rebalancing intervals, **the portfolio may drift**, and small shifts in top-ranked assets lead to more volatile allocations.\n \nThese findings suggest that **shorter rebalancing intervals better preserve the structural core** of TBTF portfolios. Quarterly updates maintain capital concentration and produce stable weight dynamics, while longer horizons may induce drift and dilute structural persistence—especially at smaller `n`.\n\n```{python}\n#| fig-cap: \"Total Turnover across Parameters\"\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nsns.boxplot(data=turnover_summary_df, x='weighting_method', y='total_turnover', hue='rebalance_freq')\nplt.title(\"Turnover Distribution by Weighting and Frequency\")\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\nsns.boxplot(\n    data=turnover_summary_df,\n    x='weighting_method',\n    y='total_turnover',\n    hue='n'  # Top-n 구성 자산 수\n)\nplt.title(\"Turnover Distribution by Weighting and Top-n\")\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n```\n\nTo assess the implementability of the TBTF strategy, we analyze total turnover across all tested configurations. As shown in the boxplot below, turnover varies substantially by weighting method and rebalancing frequency.\n\nNotably, quadratic weighting exhibits the lowest interquartile range of turnover across all rebalancing frequencies, indicating a high degree of structural stability in its portfolio composition. In contrast, equal weighting shows the widest dispersion, reflecting greater volatility in asset inclusion and reallocation.\n\nAcross all weighting methods, the effect of rebalancing frequency is pronounced. Moving from quarterly to semiannual and annual updates results in roughly a twofold increase in average turnover at each step. This highlights the tradeoff between temporal granularity and stability: longer intervals allow larger portfolio drift, necessitating more aggressive repositioning upon rebalance.\n\nTogether, these findings suggest that quadratic weighting strikes the most consistent balance between return concentration and turnover control, and that quarterly rebalancing offers a pragmatic sweet spot for retaining capital lock-in without incurring excessive trading frictions.\n\n\nFinally, we visualize the performance-turnover tradeoff, showing how each strategy balances return and implementation frictions:\n\n```{python}\n# Merge performance & turnover\nmerged_df = pd.merge(performance_df, turnover_summary_df,\n                     on=['n', 'rebalance_freq', 'weighting_method'])\n\n#| fig-cap: \"Performance Metric vs. Turnover Tradeoff\"\nsns.scatterplot(data=merged_df,\n                x='total_turnover',\n                y='Expected CRRA',\n                hue='weighting_method',\n                style='rebalance_freq')\nplt.title(\"Performance vs. Turnover Tradeoff\")\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\n```\nThe figure below visualizes the tradeoff between expected CRRA utility and total turnover across all strategy configurations. Each point represents a unique combination of `n`, `rebalance_freq`, and `weighting_method`.\n\nThe resulting plot reveals distinct horizontal clusters by rebalancing frequency, especially under the post-2010 regime. This banding effect is most likely driven by regime-specific shocks—particularly the COVID-19 crash, which had sharply divergent effects depending on the timing of portfolio adjustment.\n\nTo further analyze this, we compute the expected CRRA per unit of turnover (i.e., $\\frac{\\text{Expected CRRA}}{\\text{Total Turnover}}$) across time subperiods. During non-crisis periods, 6M and 12M configurations yield comparable ratios, with 3M performing slightly lower due to higher turnover. However, during the COVID-19 period, the 6M rebalancing interval dominates, suggesting that it hit a timing sweet spot—being responsive enough to adapt, but not overly reactive like 3M or sluggish like 12M.\n\nThese findings underscore the importance of considering macro-structural shocks in assessing turnover efficiency. While quarterly rebalancing ensures persistence and structural alignment, semiannual updates may offer better resilience under nonlinear market stress, at least in crisis regimes.\n\n\n### Summary of Robustness Findings\n\nAcross a wide range of configurations, the TBTF strategy demonstrates a **remarkable degree of structural robustness**. Its performance remains strong under variations in portfolio size, weighting rules, and rebalancing frequency—indicating that its effectiveness is not narrowly dependent on any single implementation detail. \n\nThe **outperformance of nonlinear weighting schemes** (especially exponential and quadratic) confirms that TBTF benefits are not simply a function of size, but of deliberate capital concentration. At the same time, the degradation in performance as `top_n` increases reveals that the strategy’s strength derives from a small elite of dominant firms—those at the apex of the market’s allocative structure.\n\nIn terms of implementation, **quarterly and semiannual rebalancing strike different tradeoffs**: the former preserves structural lock-in, while the latter appears more resilient during regime shocks, such as the COVID-19 crash. Turnover is manageable across both, especially under quadratic weighting, which delivers consistent stability without sacrificing performance.\n\nTaken together, these findings highlight that TBTF is not an artifact of overfitting, nor a fragile construction. It is a **structurally grounded strategy** whose persistence reflects underlying economic forces—namely, the institutional, passive, and platform-driven mechanisms that reinforce capital incumbency in modern financial markets.\n \nIn what follows, we step back from empirical validation to consider the broader implications: **What does TBTF reveal about the evolution of market efficiency, wealth concentration, and the social contract embedded in asset pricing itself?**\n","srcMarkdownNoYaml":"\n\nWhile the previous section focused on the performance outcomes of the TBTF strategy, this section evaluates the **stability of those outcomes** under variation in core implementation parameters. We test whether the superior performance persists under changes in portfolio size, rebalancing frequency, weighting schemes, and look-back windows.\n\nRather than relying on a single optimized configuration, the TBTF strategy demonstrates **structural robustness across plausible alternatives**. This not only reinforces the credibility of the results, but also supports the **practical adaptability** of the approach for different institutional contexts.\n\nAll robustness tests are performed on the post-2010 period, with out-of-sample investment beginning on **2010-01-01**. The portfolio is trained using a 48-month rolling window (`in_sample=48M`) and evaluated through 2023-12-31.\n\n```{python}\n\nimport pandas as pd\nimport sqlite3\ncons = sqlite3.connect(database=\"../../tbtf.sqlite\")\n\ncrsp = pd.read_sql_query(\n  sql=\"SELECT * FROM crsp\",\n  con=cons,\n  parse_dates={\"date\"}\n)\n\n```\n\n```{python}\n# Out-of-sample Investment\nimport sys\nimport os\n# 현재 경로 기준으로 상위 디렉토리로 경로 추가\nsys.path.append(os.path.abspath('../..'))\n\nimport tbtf\n\n\n# robust check 대상 파라미터 설정\ntop_ns = [5, 7, 10, 15, 20]\nrebalance_freqs = ['3M', '6M', '12M']\nweighting_methods = ['mean', 'quadratic', 'value', 'equal']\n\n# 기본 설정 정리\nin_end = '2009-12-31'         # in-sample 끝\nout_end = '2023-12-31'        # out-of-sample 끝\nin_sample_months = 48         # in-sample 기간 (예: 4년)\neta = 3                       # CRRA 계수\np = 0.01                      # Omega Ratio threshold\nstate = 10\n\n\nfrom joblib import Parallel, delayed\n\ndef run_single_backtest(method, n, freq):\n    result = tbtf.backtest_pipeline(\n        crsp=crsp,\n        in_end=in_end,\n        out_end=out_end,\n        in_sample_months=in_sample_months,\n        rebalance_freq=freq,\n        weighting_method=method,\n        top_n=n,\n        state=state,\n        eta=eta,\n        p=p\n    )\n    perf = result['performance']\n    perf.update({'n': n, 'rebalance_freq': freq, 'weighting_method': method})\n\n    turnover_df = result['turnover']\n    total_turnover = turnover_df.iloc[:-1]['turnover'].sum() if len(turnover_df) > 1 else np.nan\n\n    return perf, {'n': n, 'rebalance_freq': freq, 'weighting_method': method, 'total_turnover': total_turnover}\n```\n\n```{python}\n\nfrom itertools import product\n\nparam_grid = list(product(weighting_methods, top_ns, rebalance_freqs))\n\n# 병렬 실행\nresults = Parallel(n_jobs=-1)(delayed(run_single_backtest)(method, n, freq) for method, n, freq in param_grid)\n\n# Robustness check 결과 DataFrame 생성\nperformance_df = pd.DataFrame([r[0] for r in results])\nturnover_summary_df = pd.DataFrame([r[1] for r in results])\n```\n\n### Performance by Weighting Method\nWe begin by comparing the four weighting schemes: exponential (TBTF baseline), quadratic, value-weighted, and equal-weighted portfolios. The results show that TBTF's exponential weighting yields consistently superior risk-adjusted performance, particularly in terms of expected CRRA utility and downside-sensitive metrics like the Omega ratio.\n\n```{python}\n#| tbl-cap: \"Good Performance Metrics by Weighting Method\"\nmetrics = ['Expected CRRA', 'Annualized Return', 'Sharpe Ratio', 'Sortino Ratio', 'Calmar Ratio', 'Omega Ratio', 'Max Drawdown']\nperformance_df.groupby('weighting_method')[metrics].median().round(3).sort_values(by='Expected CRRA', ascending=False)\n\n```\n\n```{python}\n#| tbl-cap: \"Bad Performance Metric by Weighting Method\"\nmetrics = ['Annualized Volatility', 'Pearson Skewness', 'Excess Kurtosis']\nperformance_df.groupby('weighting_method')[metrics].median().round(3).sort_values(by='Annualized Volatility', ascending=True)\n```\n\n```{python}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n#sns.violinplot(data=performance_df, x='weighting_method', y='Annualized Volatility')\nsns.boxplot(data=performance_df, x='weighting_method', y='Sharpe Ratio')\nplt.title(\"Metric Distribution by Weighting Method\")\n```\n\nThese results suggest that nonlinear weighting schemes are critical to capturing the TBTF premium. Among them, the quadratic method slightly outperforms exponential weighting across most performance metrics, including the highest median Omega ratio (2.231) and lowest median drawdown (−13.2%). While exponential weighting reflects market power through CRRA-type concentration, the quadratic scheme appears to provide a more balanced tradeoff between concentration and diversification—delivering the best overall risk-adjusted profile among the tested methods.\n\n### Sensitivity to Asset Selection Size (`top_n`)\n\nNext, we vary the number of selected stocks, ranging from 5 to 20. The results clearly show that performance declines as top_n increases, confirming that capital concentration—not mere size exposure—is the key driver.\n\n```{python}\n#| tbl-cap: \"Sharpe Ratio by Weighting Method and Top-n\"\nperformance_df.pivot_table(\n    values='Sharpe Ratio',\n    index='weighting_method',\n    columns='n',\n    aggfunc='mean'\n)\n```\n\n```{python}\n#| tbl-cap: \"Expected CRRA Utility across Weighting Methods and Top-n\"\nperformance_df.pivot_table(\n    values='Expected CRRA',\n    index='weighting_method',\n    columns='n'\n).round(4)\n```\n\nVarying the number of selected stocks from 5 to 20 reveals a consistent pattern: risk-adjusted performance declines as the portfolio expands, regardless of weighting method. This is most clearly visible in the expected CRRA utility, where values decrease monotonically for all methods. For instance, under exponential weighting, median CRRA utility drops from 0.0175 at $n=5$ to 0.0125 at $n=20$—a 29% reduction. Similarly, the Sharpe ratio decreases from 0.6367 to 0.6026.\n\nThis pattern suggests that the TBTF premium is not a smooth function of size, but rather anchored at the extreme upper tail of the capital distribution. The diminishing returns from including more assets reinforce the structural logic of capital lock-in: only the very top firms consistently benefit from persistent investor flows, narrative insulation, and index-based reinforcement.\n\nInterestingly, quadratic weighting exhibits the most stable decay, maintaining higher CRRA utility at larger $n$ relative to exponential or value weighting. This may reflect its slightly more diversified nature, balancing concentration with convex adjustment. Equal weighting, by contrast, consistently underperforms across all $n$ values, underscoring the importance of incorporating size asymmetry into portfolio design.\n\n\n### Rebalancing Frequency and Turnover Tradeoff\n\nWe next examine the impact of rebalancing frequency—specifically, quarterly (`3M`), semiannual (`6M`), and annual (`12M`)—on risk-adjusted performance and underlying portfolio structure. As shown in the heatmap below, quarterly rebalancing tends to produce higher Sharpe ratios across most configurations, especially at smaller `n`. However, this benefit comes at the cost of substantially higher turnover, as discussed in below.\n\n```{python}\n#| fig-cap: \"Sharpe Ratio Heatmap (Top-n vs Rebalancing Frequency)\"\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# 원하는 순서로 정렬\nrebalance_order = ['3M', '6M', '12M']\nn_order = sorted(performance_df['n'].unique(), reverse=True)  # n=5,7,10,15,20 등 오름차순\n\n# Pivot and reorder\npivot_sharpe = (\n    performance_df.pivot_table(\n        values='Sharpe Ratio',\n        index='n',\n        columns='rebalance_freq'\n    )\n    .loc[n_order, rebalance_order]  # y축 (n), x축 (rebalance_freq) 순서 정렬\n    .round(2)\n)\n\n# Pivot을 위한 사용자 정의 함수\ndef best_weighting_by_sharpe(df):\n    idx = df.groupby(['n', 'rebalance_freq'])['Sharpe Ratio'].idxmax()\n    best_df = df.loc[idx, ['n', 'rebalance_freq', 'weighting_method']]\n    pivot = best_df.pivot(index='n', columns='rebalance_freq', values='weighting_method')\n\n    # 시각화-friendly 정렬\n    pivot = pivot.loc[sorted(pivot.index, reverse=True), ['3M', '6M', '12M']]\n    return pivot\n\nbest_weighting_pivot = best_weighting_by_sharpe(performance_df)\n\n# 결과 출력\n# display(best_weighting_pivot)\n\nplt.figure(figsize=(8, 5))\n# sns.heatmap(pivot_sharpe, annot=True, cmap=\"YlGnBu\", cbar_kws={'label': 'Sharpe Ratio'})\nsns.heatmap(\n    pivot_sharpe,  # 기존 numeric table\n    annot=best_weighting_pivot.values,  # 텍스트는 scheme 이름으로\n    fmt='',  # 숫자 포맷 아님\n    cmap=\"YlGnBu\",\n    cbar_kws={'label': 'Sharpe Ratio'}\n)\nplt.title(\"Best Weighting Method by Sharpe Ratio\")\nplt.xlabel(\"Rebalancing Frequency\")\nplt.ylabel(\"Number of Selected Assets (n)\")\nplt.tight_layout()\nplt.show()\n\n```\n\nBeyond performance, we investigate **portfolio stability across rebalancing intervals** using the correlation of portfolio weights between consecutive rebalancing periods. The results reveal distinct structural patterns:\n\n- Under **quarterly rebalancing (3M)**, the correlation of portfolio weights increases with `n`, rising from 0.95 at $n=5$ to nearly 1.00 at $n=20$. This reflects **high persistence** in capital allocation, especially when more firms are included.\n- In contrast, **semiannual rebalancing (6M)** exhibits a declining pattern: correlation decreases from 0.79 at $n=5$ to 0.75 at $n=20$, suggesting **greater portfolio reshuffling** under moderate rebalancing horizons.\n- For **annual rebalancing (12M)**, the relationship is **non-monotonic**, forming an inverted U-shape. Correlation peaks at $n=7$ (0.17), but falls off before and after—indicating that at longer rebalancing intervals, **the portfolio may drift**, and small shifts in top-ranked assets lead to more volatile allocations.\n \nThese findings suggest that **shorter rebalancing intervals better preserve the structural core** of TBTF portfolios. Quarterly updates maintain capital concentration and produce stable weight dynamics, while longer horizons may induce drift and dilute structural persistence—especially at smaller `n`.\n\n```{python}\n#| fig-cap: \"Total Turnover across Parameters\"\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nsns.boxplot(data=turnover_summary_df, x='weighting_method', y='total_turnover', hue='rebalance_freq')\nplt.title(\"Turnover Distribution by Weighting and Frequency\")\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\nsns.boxplot(\n    data=turnover_summary_df,\n    x='weighting_method',\n    y='total_turnover',\n    hue='n'  # Top-n 구성 자산 수\n)\nplt.title(\"Turnover Distribution by Weighting and Top-n\")\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n```\n\nTo assess the implementability of the TBTF strategy, we analyze total turnover across all tested configurations. As shown in the boxplot below, turnover varies substantially by weighting method and rebalancing frequency.\n\nNotably, quadratic weighting exhibits the lowest interquartile range of turnover across all rebalancing frequencies, indicating a high degree of structural stability in its portfolio composition. In contrast, equal weighting shows the widest dispersion, reflecting greater volatility in asset inclusion and reallocation.\n\nAcross all weighting methods, the effect of rebalancing frequency is pronounced. Moving from quarterly to semiannual and annual updates results in roughly a twofold increase in average turnover at each step. This highlights the tradeoff between temporal granularity and stability: longer intervals allow larger portfolio drift, necessitating more aggressive repositioning upon rebalance.\n\nTogether, these findings suggest that quadratic weighting strikes the most consistent balance between return concentration and turnover control, and that quarterly rebalancing offers a pragmatic sweet spot for retaining capital lock-in without incurring excessive trading frictions.\n\n\nFinally, we visualize the performance-turnover tradeoff, showing how each strategy balances return and implementation frictions:\n\n```{python}\n# Merge performance & turnover\nmerged_df = pd.merge(performance_df, turnover_summary_df,\n                     on=['n', 'rebalance_freq', 'weighting_method'])\n\n#| fig-cap: \"Performance Metric vs. Turnover Tradeoff\"\nsns.scatterplot(data=merged_df,\n                x='total_turnover',\n                y='Expected CRRA',\n                hue='weighting_method',\n                style='rebalance_freq')\nplt.title(\"Performance vs. Turnover Tradeoff\")\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\n```\nThe figure below visualizes the tradeoff between expected CRRA utility and total turnover across all strategy configurations. Each point represents a unique combination of `n`, `rebalance_freq`, and `weighting_method`.\n\nThe resulting plot reveals distinct horizontal clusters by rebalancing frequency, especially under the post-2010 regime. This banding effect is most likely driven by regime-specific shocks—particularly the COVID-19 crash, which had sharply divergent effects depending on the timing of portfolio adjustment.\n\nTo further analyze this, we compute the expected CRRA per unit of turnover (i.e., $\\frac{\\text{Expected CRRA}}{\\text{Total Turnover}}$) across time subperiods. During non-crisis periods, 6M and 12M configurations yield comparable ratios, with 3M performing slightly lower due to higher turnover. However, during the COVID-19 period, the 6M rebalancing interval dominates, suggesting that it hit a timing sweet spot—being responsive enough to adapt, but not overly reactive like 3M or sluggish like 12M.\n\nThese findings underscore the importance of considering macro-structural shocks in assessing turnover efficiency. While quarterly rebalancing ensures persistence and structural alignment, semiannual updates may offer better resilience under nonlinear market stress, at least in crisis regimes.\n\n\n### Summary of Robustness Findings\n\nAcross a wide range of configurations, the TBTF strategy demonstrates a **remarkable degree of structural robustness**. Its performance remains strong under variations in portfolio size, weighting rules, and rebalancing frequency—indicating that its effectiveness is not narrowly dependent on any single implementation detail. \n\nThe **outperformance of nonlinear weighting schemes** (especially exponential and quadratic) confirms that TBTF benefits are not simply a function of size, but of deliberate capital concentration. At the same time, the degradation in performance as `top_n` increases reveals that the strategy’s strength derives from a small elite of dominant firms—those at the apex of the market’s allocative structure.\n\nIn terms of implementation, **quarterly and semiannual rebalancing strike different tradeoffs**: the former preserves structural lock-in, while the latter appears more resilient during regime shocks, such as the COVID-19 crash. Turnover is manageable across both, especially under quadratic weighting, which delivers consistent stability without sacrificing performance.\n\nTaken together, these findings highlight that TBTF is not an artifact of overfitting, nor a fragile construction. It is a **structurally grounded strategy** whose persistence reflects underlying economic forces—namely, the institutional, passive, and platform-driven mechanisms that reinforce capital incumbency in modern financial markets.\n \nIn what follows, we step back from empirical validation to consider the broader implications: **What does TBTF reveal about the evolution of market efficiency, wealth concentration, and the social contract embedded in asset pricing itself?**\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":true,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"number-sections":true,"output-file":"4_7_robustness_copy.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","author":"gitSAM","date":"2025-03-31","bibliography":["references.bib"],"jupyter":"python3","theme":"cosmo","title":"07 Robustness","subtitle":"Is TBTF Sadly Optimal by Design?"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}