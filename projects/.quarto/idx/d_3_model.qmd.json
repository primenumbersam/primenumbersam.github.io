{"title":"AI시대 동역학 모형","markdown":{"yaml":{"title":"AI시대 동역학 모형","subtitle":"Structural Mutation Model via Automation","format":{"html":{"code-fold":true,"toc":true}},"jupyter":"python3"},"headingText":"Parameters","containsRefs":false,"markdown":"\n\n> From Closed to Open\n\nIn closed systems, labor and capital exist in mutual interaction. Labor produces output, capital accumulates via labor input, and the feedback between them sustains the economy’s dynamical structure. Such systems can cycle, stabilize, or collapse—but they do so **within** a conservative phase space.\n\nHowever, **automation** introduces a structural mutation. It does not simply accelerate capital accumulation; it changes the topology of the system itself. Capital becomes self-replicating—**decoupled** from labor. The result is a qualitative shift: the system becomes **open**, **non-conservative**, and potentially **labor-exclusionary**.\n\nWe formalize this mutation using a modified Lotka–Volterra interaction system between labor $L(t)$ and capital $C(t)$:\n\n$$\n\\frac{dL}{dt} = a_{1,1} L - a_{1,2} L C,\n$$\n\n$$\n\\frac{dC}{dt} = a_{2,1} L C + a_{2,2} C - a_{2,3} C - a_{2,4} C^2.\n$$\n\n\nEach parameter governs a fundamental mechanism:\n\n- $a_{1,1}$: autonomous growth of labor—birth, training, or onboarding.\n- $a_{1,2}$: capital-induced labor dissipation—outsourcing, automation, or deskilling.\n- $a_{2,1}$: labor-driven capital accumulation—human-centered production.\n- $a_{2,2}$: capital self-replication—automation, platform scaling, AI compounding.\n- $a_{2,3}$: depreciation—maintenance, obsolescence, or asset decay.\n- $a_{2,4}$: **nonlinear dissipation within capital**—interpreted not merely as diminishing returns, but as **elite–elite rivalry**, strategic cannibalism, and systemic congestion at the top.\n\nThe first equation describes labor's fate: a positive growth term ($a_{1,1} L$) is offset by an absorption term ($-a_{1,2} L C$), which accelerates as capital increases. This structure encodes labor's vulnerability to capital dominance: if capital grows faster than labor, labor becomes increasingly exposed to structural replacement.\n\nThe second equation governs capital: it can grow through labor ($a_{2,1} LC$), but also through internal momentum ($a_{2,2} C$), so long as depreciation ($a_{2,3} C$) and dissipation ($a_{2,4} C^2$) do not overwhelm it.\n\nThe nonlinearity introduced by $-a_{2,4} C^2$ is essential. Unlike traditional diminishing returns, which reduce marginal productivity, this term reflects **conflict internal to the elite class**. In financialized economies where capital is abundant and labor is scarce or irrelevant, competition is not against workers—it is against **other capital holders**. Here, $C^2$ signifies **structural overcrowding** at the top: redundant infrastructure, speculative bubbles, or defensive investments to block new entrants. It is not friction from scarcity; it is friction from saturation.\n\n## Asymptotic Scenarios\n\nThis system admits multiple asymptotic regimes depending on the relationship between parameter values:\n\n**1. Classical Mutualism (Closed System)**  \nWhen $a_{2,2} = 0$ and $a_{1,1}, a_{2,1}, a_{1,2}, a_{2,3} > 0$, the system behaves like a classical Lotka–Volterra cycle:\n\n- $L$ grows when capital is low, declines when capital is high.\n- $C$ grows when labor is abundant, decays otherwise.\n- Orbits emerge in the phase space, bounded and conservative.\n\n**Interpretation:** Capital and labor are locked in mutual dependence. Neither can survive alone.\n\n\n**2. Transitional Instability (Automation Activation)**  \nWhen $a_{2,2} > 0$ but still small relative to $a_{2,1} L$ in most regions, the system begins to destabilize:\n\n- $C$ receives a small automation boost.\n- If labor weakens slightly, $C$ continues to grow—less dependent on $L$.\n- Feedback begins to **tilt asymmetrically** toward capital dominance.\n\n**Interpretation:** The system is **no longer symmetric**. Capital begins to escape the orbit of labor.\n\n\n**3. Structural Mutation (Irreversibility Activated)**  \nOnce $a_{2,2} C \\gg a_{2,1} LC$, capital’s growth is no longer a function of labor.\n\nConditions for mutation:\n\n- $a_{2,2} > a_{2,3}$: capital can grow faster than it decays,\n- $a_{1,2} C > a_{1,1}$: labor is absorbed faster than it reproduces,\n- $a_{2,4} C$ is not too large: elite–elite rivalry remains subcritical.\n\nThen:\n\n- $L(t) \\to 0$,  \n- $C(t) \\to C^* > 0$ (if friction), or $\\to \\infty$ (if friction is weak),  \n- $(L = 0, C = C^*)$ becomes an **absorbing state**—a terminal attractor.\n\n**Interpretation:** Labor is not outcompeted—it is made **irrelevant**. Capital sustains itself and eventually **excludes labor** from its dynamic logic.\n\n\n**4. Elite Saturation Collapse**  \nIf $a_{2,4}$ becomes too large (e.g., due to capital hoarding, overconcentration, or elite cannibalism):\n\n- Even autonomous capital growth stalls,\n- $C(t)$ declines after reaching a peak,\n- System may stabilize at a **low-labor, low-capital** regime—or collapse entirely.\n\n**Interpretation:** Overaccumulation leads to **implosion**. Not because of labor resistance, but from **excess at the top**.\n\n## Structural Irreversibility and Phase Space Mutation\n\nThe transition from a labor–capital mutual system to one governed by autopoietic capital dynamics is not gradual—it is governed by a critical threshold beyond which the system undergoes a **topological mutation**. Prior to this threshold, the system behaves conservatively: labor and capital remain coupled through mutual feedback, and trajectories in the phase space exhibit cyclical or bounded behavior. However, once capital exceeds a structurally determined critical level, the term $a_{2,2}C$ overtakes labor-mediated growth ($a_{2,1}LC$), shifting the dynamical core from interaction to self-replication. At this point, the system’s structure changes discontinuously: closed orbits vanish, invariant sets collapse toward the capital axis, and the line $L=0$ becomes an **absorbing boundary**. Labor, once displaced, cannot re-enter the system—a condition of **topological irreversibility**. The phase space itself no longer supports recovery pathways. This transformation is not a new equilibrium within the same geometry; it is a qualitative reconfiguration of the geometry itself.\n\nThis structural interpretation of automation reveals it as a **mechanism of decoupling**, not simply one of acceleration. It dismantles the co-evolutionary logic of labor and capital, replacing it with an extractive trajectory that systematically erodes labor's role. As labor vanishes, the site of conflict shifts inward: among capital holders themselves. The nonlinear dissipation term $a_{2,4}C^2$ captures this emergent **elite–elite competition**, where positional advantage and resource saturation determine outcomes. The core asymmetry of the system thus moves from inter-class struggle to **intra-elite positional rivalry**—a transformation concealed in aggregate growth but revealed in structural dynamics.\n\nWith this theoretical architecture established, we now turn to the empirical question: does current macroeconomic data exhibit signals of this irreversible transition? In the following section, we estimate the parameters of the system using historical data and identify which regime—closed, transitional, or exclusionary—the contemporary economy occupies within the modeled phase space.\n\n## Estimating Parameters with Level Data\n\nThe empirical calibration of structural dynamical models often begins with time series data expressed in **absolute levels**. In the context of labor–capital systems, this typically involves tracking population, capital stock, investment flows, and income components—each representing one component of the theoretical system:\n\n$$\n\\begin{aligned}\n\\frac{dL}{dt} &= a_{1,1} L - a_{1,2} L C, \\\\\n\\frac{dC}{dt} &= a_{2,1} L C + a_{2,2} C - a_{2,3} C - a_{2,4} C^2.\n\\end{aligned}\n$$\n\nEach parameter in this system has a corresponding economic interpretation, often approximated using national account statistics or industry-level indicators:\n\n| Parameter       | Interpretation                               | Empirical Proxy                                 |\n|----------------|-----------------------------------------------|--------------------------------------------------|\n| $a_{1,1}$       | Endogenous labor growth                      | Population and participation rates (BLS, UN)     |\n| $a_{1,2}$       | Capital-induced labor absorption             | Wage–productivity divergence, labor share trend  |\n| $a_{2,1}$       | Labor-driven capital formation               | Profit per worker, reinvestment ratios           |\n| $a_{2,2}$       | Automation-induced capital growth            | Robot density, IT capital share, patent counts   |\n| $a_{2,3}$       | Capital depreciation                         | Consumption of fixed capital (BEA, Eurostat)     |\n| $a_{2,4}$       | Frictions to capital expansion               | Diminishing returns, saturation metrics          |\n\nWhile conceptually straightforward, level-based estimation encounters several technical and interpretive challenges. Among these:\n\n- **High sensitivity to measurement errors** in levels, especially when working with small changes (e.g., net investment).\n- **Heterogeneity in units and scaling**, which complicates system-level identification without extensive normalization.\n- **Implicit steady-state assumptions**, particularly when using calibration methods that fix terminal values or target observed ratios (e.g., $C^*/Y^*$ or $K/L$ ratios).\n- **Dependence on aggregation conventions**, such as capital stock estimation or depreciation schedules, which vary significantly across countries and sources.\n\nA variety of empirical strategies have been employed in this context:\n\n- **Closed-form identification**: Parameters like $a_{2,3}$ (capital depreciation) can often be directly observed from national accounts.\n- **Time-series regression**: Parameters such as $a_{2,2}$ (automation growth) or $a_{1,2}$ (labor extraction rate) can be estimated by regressing capital growth or labor share decline on automation-related indicators.\n- **Steady-state calibration**: Assuming long-run convergence, one can calibrate parameters to match terminal or average observed values (e.g., setting $a_{2,4}$ to ensure bounded $C$ given observed capital-output ratios).\n- **Bayesian updating**: Priors from the macroeconomic literature (e.g., Solow-type growth parameters) are updated using observed data.\n- **System-level structural estimation**: Full-model techniques such as GMM or maximum likelihood estimation (MLE) are applied to estimate coupled ODEs from observed $(L_t, C_t)$ time series.\n\nDespite its prevalence, the level-based framework is limited in its ability to track **distributional dynamics** or **relative concentration patterns**, particularly in systems undergoing **structural mutation**. In such cases, absolute levels may grow exponentially while the internal composition of the system changes qualitatively.\n\nTo address these limitations, the next section introduces a **share-based estimation strategy** that reinterprets elite capital concentration data as a proxy for system-level capital dominance, enabling estimation of nonlinear dynamics via normalized replicator-like forms. This approach aligns more naturally with inequality-focused modeling, where relative shares and structural saturation matter more than total quantities.\n\n\n## Estimating Parameters with Share Data\n\nTraditional macroeconomic estimation strategies are typically rooted in level data—aggregate capital stock, total output, labor force levels—used to calibrate dynamic models of production, accumulation, and distribution. While effective in certain contexts, this approach suffers from scaling inconsistencies, comparability issues across time, and sensitivity to nominal shocks. Moreover, level data fails to reveal the **internal stratification** of economic systems—particularly the **distribution of capital** across heterogeneous agents.\n\nTo address this, we introduce a share-based approach. Rather than modeling the absolute size of capital or labor, we model their **relative shares**: \n\n- Capital share: $c(t) = \\frac{C(t)}{C(t) + L(t)}$\n- Labor share: $\\ell(t) = 1 - c(t)$\n\nThis reframing allows us to interpret economic dynamics in terms of **structural positioning** and **relative dominance**, rather than absolute growth. Importantly, this representation is **invariant to total system size**, rendering it more robust for long-term analysis and cross-group comparison.\n\n### U.S. Wealth Share Data (1989–2024, Quarterly)\n\nWe utilize quarterly data from the Federal Reserve's Distributional Financial Accounts (via FRED) to construct empirical capital share trajectories for three elite percentile groups:\n\n- **Top 0.1% Net Wealth Share** (`WFRBSTP1300`)\n- **Top 1% Net Wealth Share** (`WFRBST01134`)\n- **Top 10% Net Wealth Share**, computed as the sum of top 1% and 90–99% (`WFRBSN09161`)\n\nThese series serve as empirical proxies for the **capital share** $c(t)$ held by each group. Corresponding labor shares are then computed as $\\ell(t) = 1 - c(t)$.\n\nThis share-based framing bypasses issues with raw levels (GDP deflators, capital depreciation schedules, labor hours) and instead centers the analysis on **relative control over accumulated wealth**—a key structural feature in capitalist systems.\n\n\n### Share-Based Dynamics\n\nThe structural labor–capital model is given in level terms as:\n\n$$\n\\begin{aligned}\n\\frac{dL}{dt} &= a_{11} L - a_{12} L C, \\\\\n\\frac{dC}{dt} &= a_{21} L C + a_{22} C - a_{23} C - a_{24} C^2.\n\\end{aligned}\n$$\n\nDefine total system size $S(t) = L(t) + C(t)$ and the **capital share**:\n$$\nc(t) = \\frac{C(t)}{S(t)}.\n$$\n\nBy differentiating this definition with respect to time:\n$$\n\\frac{dc}{dt} = \\frac{\\dot{C} S - C \\dot{S}}{S^2}.\n$$\n\nSubstituting the dynamics:\n- $\\dot{C} = a_{21} L C + a_{22} C - a_{23} C - a_{24} C^2$\n- $\\dot{L} = a_{11} L - a_{12} L C$\n- So $\\dot{S} = \\dot{L} + \\dot{C}$\n\nNow let $C = c S$, $L = (1 - c) S$ to express everything in terms of $c(t)$ and $S(t)$.\n\nAssuming $a_{21} \\approx 0$ (negligible labor-driven capital growth) and quasi-stationary $S(t)$ over short windows, the expression simplifies to:\n\n$$\n\\frac{dc}{dt} \\approx c (a_{22} - a_{24} c).\n$$\n\nThis **replicator-type equation** captures the nonlinear interplay between:\n\n- **Self-replicating capital** (via $a_{22}$), and\n- **Intra-elite saturation effects** (via $a_{24}$).\n\nEmpirically, this continuous form becomes:\n$$\n\\frac{\\Delta c_t}{c_t} \\approx a_{22}(t) - a_{24}(t) c_t.\n$$\n\nBy running **rolling-window OLS regressions** (e.g., 20 quarters), we estimate $a_{22}(t)$ and $a_{24}(t)$ as **time-varying structural coefficients**, capturing technological change, financial regime shifts, and institutional transitions.\n\nTo estimate the remaining parameters, we turn to the full coupled system. Normalizing the labor-capital system in share terms:\n\n- For labor:\n$$\n\\frac{\\Delta \\ell_t}{\\ell_t} = a_{11}(t) - a_{12}(t) c_t + \\varepsilon_t.\n$$\n\n- For capital (expanded):\n$$\n\\frac{\\Delta c_t}{c_t} = a_{21}(t) \\ell_t + a_{22}(t) - a_{23}(t) - a_{24}(t) c_t + \\varepsilon_t.\n$$\n\nGiven previously estimated $a_{22}(t)$ and $a_{24}(t)$, and setting $a_{23}(t) = 0.025$ (fixed quarterly depreciation), we identify:\n\n- $a_{11}(t), a_{12}(t)$: from labor-share regression,\n- $a_{21}(t)$: by back-solving from capital equation residuals.\n\n\n### Empirical Findings\n\n1. **$a_{22}(t)$** rises sharply during known automation epochs: dot-com boom, smartphone era, and post-2020 AI expansion.\n2. **$a_{24}(t)$** is consistently positive and increasing with percentile, indicating growing intra-elite competition.\n3. **$a_{21}(t) \\approx 0$ across all groups**, sometimes on the order of $10^{-7}$ or lower.\n\n> This implies that capital is **self-reproducing**, with minimal dependence on labor—a hallmark of late-stage automation economies.\n\nHowever, setting $a_{21} = 0$ creates degenerate dynamics: over time, both capital and labor vanish. Surprisingly, even capital collapses without minimal labor input.\n\nBy setting $a_{21} = 0.0007$ (small but positive), simulations match observed empirical tail behavior in $c(t)$—showing that even **negligible labor-capital coupling** is structurally vital for long-run viability.\n\nThese findings underscore the fragility of modern accumulation systems. The capital-labor system is not sustained by productivity, but by **network-dependent feedback loops**. Small structural parameters—such as $a_{21}$—govern the **existence of long-run attractors**.\n\nPolicy interventions must thus go beyond redistribution. They must alter structural parameters:\n- Lower $a_{12}$ to reduce labor extraction,\n- Cap $a_{24}$ to prevent elite overaccumulation,\n- Increase $a_{21}$ via labor-linked investment,\n- Shift $a_{22}$ toward inclusive automation.\n\nThis model reframes inequality not as an outcome of imbalance, but as a **phase-space feature**—a geometrical consequence of structural dynamics. In summary, share-based empirical modeling reveals structural dependencies invisible in level-data systems. The future of capital depends not on output maximization, but on the topology of feedback and the fragility of replication.\n\n\n## Plots\n\n### US Wealth Share Data\n\n```{python}\n#| label: fig-us-data-load\n#| tbl-cap: \"Quarterly net wealth share data (Top 0.1%, 1%, and 10%) are retrieved directly from the FRED database and used to compute normalized capital share trajectories over the period 1989Q3 to 2024Q4.\"\n\nimport pandas_datareader.data as web\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\nfrom scipy.stats import trim_mean, mode\n\n# Define the time range\nstart_date = \"1989-07-01\"\nend_date = \"2024-10-01\"\n\n# Download data directly for each group\ndata = {}\ndata['Top 0.1%'] = web.DataReader('WFRBSTP1300', 'fred', start_date, end_date)\ndata['Top 1%'] = web.DataReader('WFRBST01134', 'fred', start_date, end_date)\ndata['Top 90-99%'] = web.DataReader('WFRBSN09161', 'fred', start_date, end_date)\n\n# Combine Top 1% and 90-99% to compute Top 10%\ntop_10 = pd.DataFrame(index=data['Top 1%'].index)\ntop_10['Top 10%'] = data['Top 1%']['WFRBST01134'] + data['Top 90-99%']['WFRBSN09161']\n\n# Combine all into a single DataFrame for analysis\ndf = pd.DataFrame(index=data['Top 0.1%'].index)\ndf['Top 0.1%'] = data['Top 0.1%']['WFRBSTP1300']\ndf['Top 1%'] = data['Top 1%']['WFRBST01134']\ndf['Top 10%'] = top_10['Top 10%']\n\ndf = df.dropna()\n\nprint(\"Sample Start: \", start_date)\nprint(\"Sample End: \", end_date)\ndf.head()\n```\n\n### Time-Varying Parameter Estimates (All Groups)\n\n```{python}\n# Time-varying parameter estimation for each wealth share group, using a rolling window regression on the nonlinear replicator-transformed system. Parameters $a_{2,2}(t)$ and $a_{2,4}(t)$ are inferred from capital share growth, while $a_{1,1}(t)$ and $a_{1,2}(t)$ are extracted from labor share contraction. Residual dynamics yield estimates of $a_{2,1}(t)$ and implied $a_{2,3}(t)$.\n\n# Calculate c(t) and l(t) for each group\nct_01 = df['Top 0.1%']\nct_1 = df['Top 1%']\nct_10 = df['Top 10%']\n\nlt_01 = 1 - ct_01\nlt_1 = 1 - ct_1\nlt_10 = 1 - ct_10\n\n# Define a function to compute rolling parameter estimates\ndef estimate_parameters(c_t, window=20, depreciation=0.025):\n    c_t = c_t.dropna()\n    l_t = 1 - c_t\n    dc = c_t.diff()\n    dl = l_t.diff()\n    c_t_lag = c_t.shift(1)\n    l_t_lag = l_t.shift(1)\n    \n    rel_dc = (dc / c_t_lag).dropna()\n    rel_dl = (dl / l_t_lag).dropna()\n\n    df_rolling = pd.DataFrame({\n        'c': c_t_lag,\n        'l': l_t_lag,\n        'dc_rel': rel_dc,\n        'dl_rel': rel_dl\n    }).dropna()\n\n    results = []\n\n    for i in range(window, len(df_rolling)):\n        window_df = df_rolling.iloc[i - window:i]\n        X_c = np.vstack([np.ones(window), -window_df['c']]).T\n        y_c = window_df['dc_rel']\n        a22, a24 = np.linalg.lstsq(X_c, y_c, rcond=None)[0]\n\n        X_l = np.vstack([np.ones(window), -window_df['c']]).T\n        y_l = window_df['dl_rel']\n        a11, a12 = np.linalg.lstsq(X_l, y_l, rcond=None)[0]\n\n        a21_minus_a23 = y_c - (a22 - a24 * window_df['c'])\n        X_a21 = window_df['l']\n        a21 = np.mean(a21_minus_a23 / X_a21)\n        a23 = a21 - depreciation  # using assumed depreciation\n\n        results.append({\n            'date': df_rolling.index[i],\n            'a11': a11,\n            'a12': a12,\n            'a21': a21,\n            'a22': a22,\n            'a23': a23,\n            'a24': a24\n        })\n\n    return pd.DataFrame(results).set_index('date')\n\n# Estimate for all three groups\nres_df_01 = estimate_parameters(ct_01, window=20)\nres_df_1 = estimate_parameters(ct_1, window=20)\nres_df_10 = estimate_parameters(ct_10, window=20)\n```\n\n\n```{python}\n#| label: fig-rolling-params-all\n#| fig-cap: \"Estimated time-varying parameters for each wealth percentile group, based on rolling window regressions. Each panel corresponds to one structural parameter of the labor–capital dynamic system. Differences across percentile groups reflect heterogeneity in structural regimes, such as automation dominance ($a_{2,2}$) or labor extraction intensity ($a_{1,2}$).\"\n\n# 추정 대상 그룹\ngroup_labels = ['Top 0.1%', 'Top 1%', 'Top 10%']\nresults = [res_df_01, res_df_1, res_df_10]\n\n# 파라미터 목록\nparams = ['a11', 'a12', 'a21', 'a22', 'a23', 'a24']\n\n# Plotting\nfig, axes = plt.subplots(3, 2, figsize=(16, 12), sharex=True)\naxes = axes.flatten()\n\nfor i, param in enumerate(params):\n    for group_df, label in zip(results, group_labels):\n        if param in group_df.columns:\n            axes[i].plot(group_df.index, group_df[param], label=label)\n    axes[i].set_title(f\"Parameter: {param}\")\n    axes[i].legend()\n    axes[i].grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n### Distribution of Estimated Parameters (Histogram)\n\n```{python}\n#| label: fig-parameter-histograms\n#| fig-cap: \"Empirical distribution of estimated parameters across Top 0.1%, Top 1%, and Top 10% wealth share groups. Each subplot overlays the histogram of a single parameter's rolling estimates for all three groups. The visual comparison reveals systematic differences in structural dynamics across percentile tiers.\"\n\nimport matplotlib.pyplot as plt\n\n# 추정된 모든 파라미터 리스트\nparameters = ['a11', 'a12', 'a21', 'a22', 'a23', 'a24']\ngroup_dfs = [res_df_01, res_df_1, res_df_10]\ngroup_labels = ['Top 0.1%', 'Top 1%', 'Top 10%']\ncolors = ['tab:blue', 'tab:orange', 'tab:green']\n\nfig, axes = plt.subplots(3, 2, figsize=(14, 10))\naxes = axes.flatten()\n\nfor i, param in enumerate(parameters):\n    ax = axes[i]\n    for df, label, color in zip(group_dfs, group_labels, colors):\n        ax.hist(df[param].dropna(), bins=50, alpha=0.6, label=label, color=color)\n    ax.set_title(f\"Parameter: {param}\")\n    ax.set_xlabel(\"Value\")\n    ax.set_ylabel(\"Frequency\")\n    ax.legend()\n    ax.grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n## Parameter Summary Table: Group-Wise Statistics by Parameter\n\n```{python}\n#| label: tbl-param-summary-wide\n#| tbl-cap: \"Parameter-wise summary statistics across elite groups (Top 0.1%, Top 1%, Top 10%), including median, trimmed mean, and mode for each parameter.\"\n\ndepreciation = 0.025\n\nprint(\"depreciation a23 (quarterly): \", depreciation)\n\nfrom scipy.stats import trim_mean, mode\n\n# Define a function to compute descriptive statistics for each parameter\ndef summarize_parameters(df, name):\n    summary = pd.DataFrame(index=df.columns)\n    summary[\"median\"] = df.median()\n    summary[\"trimmed_mean\"] = df.apply(lambda x: trim_mean(x.dropna(), 0.1))\n    summary[\"mode\"] = df.mode().iloc[0]\n    summary[\"group\"] = name\n    return summary\n\nsummary_01 = summarize_parameters(res_df_01, \"Top 0.1%\")\nsummary_1 = summarize_parameters(res_df_1, \"Top 1%\")\nsummary_10 = summarize_parameters(res_df_10, \"Top 10%\")\n\n# Combine summaries\nparam_summary = pd.concat([summary_01, summary_1, summary_10])\nparam_summary = param_summary.reset_index().rename(columns={\"index\": \"parameter\"})\n\n# Overwrite a23 with constant 0.25 (quarterly) for all groups\nparam_summary.loc[param_summary[\"parameter\"] == \"a23\", [\"median\", \"trimmed_mean\", \"mode\"]] = depreciation\n\n# Extract median values as parameter sets\ndef extract_params(df, group_name, depreciation=0.025):\n    row = df[df[\"group\"] == group_name].set_index(\"parameter\")\n    return {\n        \"a11\": row.loc[\"a11\", \"median\"],\n        \"a12\": row.loc[\"a12\", \"median\"],\n        \"a21\": row.loc[\"a21\", \"median\"],\n        \"a22\": row.loc[\"a22\", \"median\"],\n        \"a23\": depreciation,  # override\n        \"a24\": row.loc[\"a24\", \"median\"]\n    }\n\nparams_top_01 = extract_params(param_summary, \"Top 0.1%\")\nparams_top_1 = extract_params(param_summary, \"Top 1%\")\nparams_top_10 = extract_params(param_summary, \"Top 10%\")\n\n# Define representative median parameters (with calibrated a23 = 0.025)\n\n# 통계량별로 long-form에서 wide-form으로 pivot\npivot_all = param_summary.pivot_table(\n    index=\"parameter\",\n    columns=\"group\",\n    values=[\"median\", \"trimmed_mean\", \"mode\"]\n)\n\n# 열 순서를 보기 좋게 정렬\nordered_columns = [\n    (\"median\", \"Top 0.1%\"), (\"median\", \"Top 1%\"), (\"median\", \"Top 10%\"),\n    (\"trimmed_mean\", \"Top 0.1%\"), (\"trimmed_mean\", \"Top 1%\"), (\"trimmed_mean\", \"Top 10%\"),\n    (\"mode\", \"Top 0.1%\"), (\"mode\", \"Top 1%\"), (\"mode\", \"Top 10%\"),\n]\npivot_all = pivot_all[ordered_columns]\n\n# 소수점 자리수 정리\npivot_all = pivot_all.round(5)\npivot_all\n\n```\n\n## Simulated System Dynamics with Calibrated Labor-Driven Capital Growth ($a_{21} = 0.0007$)\n\n```{python}\n#| label: fig-sim-dynamics-shares\n#| fig-cap: \"Simulated time-domain capital share dynamics $c(t)$ for each percentile group using calibrated $a_{21} = 0.0007$ and median parameter values.\"\n\nfrom scipy.integrate import solve_ivp\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define the system of ODEs with fixed a21 = 0.0007\ndef simulate_system(params, L0=10, C0=3, t_span=(0, 140), t_steps=2000):\n    def system(t, y):\n        L, C = y\n        a11, a12, a21, a22, a23, a24 = (\n            params[\"a11\"], params[\"a12\"], 0.0007,  # fixed!\n            params[\"a22\"], params[\"a23\"], params[\"a24\"]\n        )\n        dLdt = a11 * L - a12 * L * C\n        dCdt = a21 * L * C + a22 * C - a23 * C - a24 * C**2\n        return [dLdt, dCdt]\n\n    t_eval = np.linspace(t_span[0], t_span[1], t_steps)\n    sol = solve_ivp(system, t_span, [L0, C0], t_eval=t_eval)\n    return sol.t, sol.y[0], sol.y[1]\n\n# Simulations for each group\nt, L_01, C_01 = simulate_system(params_top_01)\n_, L_1, C_1 = simulate_system(params_top_1)\n_, L_10, C_10 = simulate_system(params_top_10)\n\n# Normalize to capital share c(t)\nc_01 = C_01 / (L_01 + C_01)\nc_1 = C_1 / (L_1 + C_1)\nc_10 = C_10 / (L_10 + C_10)\n\n# Plot: Capital share over time\nplt.figure(figsize=(12, 5))\nplt.plot(t, c_01, label=\"Top 0.1%\", linewidth=2)\nplt.plot(t, c_1, label=\"Top 1%\", linewidth=2)\nplt.plot(t, c_10, label=\"Top 10%\", linewidth=2)\nplt.title(\"Simulated Capital Share Dynamics by Group ($a_{21} = 0.0007$)\")\nplt.xlabel(\"Time (Quarters)\")\nplt.ylabel(\"Capital Share $c(t)$\")\nplt.ylim(0, 1.05)\nplt.grid(True)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```\n\n\n```{python}\n#| label: fig-phase-space-level\n#| fig-cap: \"Level-Based Phase Space with Vector Field and Simulated Trajectories\"\n# \"Simulated phase trajectories and normalized vector fields in $(L, C)$ space for each percentile group, using calibrated $a_{21} = 0.0007$.\"\n\n# Define simulation function\ndef simulate_system(params, L0=10, C0=3, t_span=(0, 140), t_steps=2000):\n    def system(t, y):\n        L, C = y\n        dLdt = params[\"a11\"] * L - params[\"a12\"] * L * C\n        dCdt = 0.0007 * L * C + params[\"a22\"] * C - params[\"a23\"] * C - params[\"a24\"] * C**2\n        return [dLdt, dCdt]\n    t_eval = np.linspace(t_span[0], t_span[1], t_steps)\n    sol = solve_ivp(system, t_span, [L0, C0], t_eval=t_eval)\n    return sol.t, sol.y[0], sol.y[1]\n\n# Grid for vector field\nL_vals = np.linspace(0, 150, 150)\nC_vals = np.linspace(0, 150, 150)\nL_grid, C_grid = np.meshgrid(L_vals, C_vals)\n\n# Plotting\nfig, axes = plt.subplots(1, 3, figsize=(18, 6))\ngroup_params = {\n    \"Top 0.1%\": params_top_01,\n    \"Top 1%\": params_top_1,\n    \"Top 10%\": params_top_10\n}\n\nfor ax, (label, params) in zip(axes, group_params.items()):\n    # Vector field\n    a11, a12 = params[\"a11\"], params[\"a12\"]\n    a22, a23, a24 = params[\"a22\"], params[\"a23\"], params[\"a24\"]\n    a21 = 0.0007  # fixed\n\n    dL = a11 * L_grid - a12 * L_grid * C_grid\n    dC = a21 * L_grid * C_grid + a22 * C_grid - a23 * C_grid - a24 * C_grid**2\n    mag = np.sqrt(dL**2 + dC**2)\n    dL_norm = dL / (mag + 1e-8)\n    dC_norm = dC / (mag + 1e-8)\n\n    ax.quiver(L_grid, C_grid, dL_norm, dC_norm, angles='xy', color='gray', alpha=0.5)\n\n    # Trajectory\n    t, L_sim, C_sim = simulate_system(params)\n    ax.plot(L_sim, C_sim, 'r-', linewidth=2, label='Trajectory')\n\n    ax.set_title(f\"Phase Space: {label}\")\n    ax.set_xlabel(\"Labor (L)\")\n    ax.set_ylabel(\"Capital (C)\")\n    ax.set_xlim(0, 150)\n    ax.set_ylim(0, 150)\n    ax.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n```\n","srcMarkdownNoYaml":"\n\n> From Closed to Open\n\nIn closed systems, labor and capital exist in mutual interaction. Labor produces output, capital accumulates via labor input, and the feedback between them sustains the economy’s dynamical structure. Such systems can cycle, stabilize, or collapse—but they do so **within** a conservative phase space.\n\nHowever, **automation** introduces a structural mutation. It does not simply accelerate capital accumulation; it changes the topology of the system itself. Capital becomes self-replicating—**decoupled** from labor. The result is a qualitative shift: the system becomes **open**, **non-conservative**, and potentially **labor-exclusionary**.\n\nWe formalize this mutation using a modified Lotka–Volterra interaction system between labor $L(t)$ and capital $C(t)$:\n\n$$\n\\frac{dL}{dt} = a_{1,1} L - a_{1,2} L C,\n$$\n\n$$\n\\frac{dC}{dt} = a_{2,1} L C + a_{2,2} C - a_{2,3} C - a_{2,4} C^2.\n$$\n\n## Parameters\n\nEach parameter governs a fundamental mechanism:\n\n- $a_{1,1}$: autonomous growth of labor—birth, training, or onboarding.\n- $a_{1,2}$: capital-induced labor dissipation—outsourcing, automation, or deskilling.\n- $a_{2,1}$: labor-driven capital accumulation—human-centered production.\n- $a_{2,2}$: capital self-replication—automation, platform scaling, AI compounding.\n- $a_{2,3}$: depreciation—maintenance, obsolescence, or asset decay.\n- $a_{2,4}$: **nonlinear dissipation within capital**—interpreted not merely as diminishing returns, but as **elite–elite rivalry**, strategic cannibalism, and systemic congestion at the top.\n\nThe first equation describes labor's fate: a positive growth term ($a_{1,1} L$) is offset by an absorption term ($-a_{1,2} L C$), which accelerates as capital increases. This structure encodes labor's vulnerability to capital dominance: if capital grows faster than labor, labor becomes increasingly exposed to structural replacement.\n\nThe second equation governs capital: it can grow through labor ($a_{2,1} LC$), but also through internal momentum ($a_{2,2} C$), so long as depreciation ($a_{2,3} C$) and dissipation ($a_{2,4} C^2$) do not overwhelm it.\n\nThe nonlinearity introduced by $-a_{2,4} C^2$ is essential. Unlike traditional diminishing returns, which reduce marginal productivity, this term reflects **conflict internal to the elite class**. In financialized economies where capital is abundant and labor is scarce or irrelevant, competition is not against workers—it is against **other capital holders**. Here, $C^2$ signifies **structural overcrowding** at the top: redundant infrastructure, speculative bubbles, or defensive investments to block new entrants. It is not friction from scarcity; it is friction from saturation.\n\n## Asymptotic Scenarios\n\nThis system admits multiple asymptotic regimes depending on the relationship between parameter values:\n\n**1. Classical Mutualism (Closed System)**  \nWhen $a_{2,2} = 0$ and $a_{1,1}, a_{2,1}, a_{1,2}, a_{2,3} > 0$, the system behaves like a classical Lotka–Volterra cycle:\n\n- $L$ grows when capital is low, declines when capital is high.\n- $C$ grows when labor is abundant, decays otherwise.\n- Orbits emerge in the phase space, bounded and conservative.\n\n**Interpretation:** Capital and labor are locked in mutual dependence. Neither can survive alone.\n\n\n**2. Transitional Instability (Automation Activation)**  \nWhen $a_{2,2} > 0$ but still small relative to $a_{2,1} L$ in most regions, the system begins to destabilize:\n\n- $C$ receives a small automation boost.\n- If labor weakens slightly, $C$ continues to grow—less dependent on $L$.\n- Feedback begins to **tilt asymmetrically** toward capital dominance.\n\n**Interpretation:** The system is **no longer symmetric**. Capital begins to escape the orbit of labor.\n\n\n**3. Structural Mutation (Irreversibility Activated)**  \nOnce $a_{2,2} C \\gg a_{2,1} LC$, capital’s growth is no longer a function of labor.\n\nConditions for mutation:\n\n- $a_{2,2} > a_{2,3}$: capital can grow faster than it decays,\n- $a_{1,2} C > a_{1,1}$: labor is absorbed faster than it reproduces,\n- $a_{2,4} C$ is not too large: elite–elite rivalry remains subcritical.\n\nThen:\n\n- $L(t) \\to 0$,  \n- $C(t) \\to C^* > 0$ (if friction), or $\\to \\infty$ (if friction is weak),  \n- $(L = 0, C = C^*)$ becomes an **absorbing state**—a terminal attractor.\n\n**Interpretation:** Labor is not outcompeted—it is made **irrelevant**. Capital sustains itself and eventually **excludes labor** from its dynamic logic.\n\n\n**4. Elite Saturation Collapse**  \nIf $a_{2,4}$ becomes too large (e.g., due to capital hoarding, overconcentration, or elite cannibalism):\n\n- Even autonomous capital growth stalls,\n- $C(t)$ declines after reaching a peak,\n- System may stabilize at a **low-labor, low-capital** regime—or collapse entirely.\n\n**Interpretation:** Overaccumulation leads to **implosion**. Not because of labor resistance, but from **excess at the top**.\n\n## Structural Irreversibility and Phase Space Mutation\n\nThe transition from a labor–capital mutual system to one governed by autopoietic capital dynamics is not gradual—it is governed by a critical threshold beyond which the system undergoes a **topological mutation**. Prior to this threshold, the system behaves conservatively: labor and capital remain coupled through mutual feedback, and trajectories in the phase space exhibit cyclical or bounded behavior. However, once capital exceeds a structurally determined critical level, the term $a_{2,2}C$ overtakes labor-mediated growth ($a_{2,1}LC$), shifting the dynamical core from interaction to self-replication. At this point, the system’s structure changes discontinuously: closed orbits vanish, invariant sets collapse toward the capital axis, and the line $L=0$ becomes an **absorbing boundary**. Labor, once displaced, cannot re-enter the system—a condition of **topological irreversibility**. The phase space itself no longer supports recovery pathways. This transformation is not a new equilibrium within the same geometry; it is a qualitative reconfiguration of the geometry itself.\n\nThis structural interpretation of automation reveals it as a **mechanism of decoupling**, not simply one of acceleration. It dismantles the co-evolutionary logic of labor and capital, replacing it with an extractive trajectory that systematically erodes labor's role. As labor vanishes, the site of conflict shifts inward: among capital holders themselves. The nonlinear dissipation term $a_{2,4}C^2$ captures this emergent **elite–elite competition**, where positional advantage and resource saturation determine outcomes. The core asymmetry of the system thus moves from inter-class struggle to **intra-elite positional rivalry**—a transformation concealed in aggregate growth but revealed in structural dynamics.\n\nWith this theoretical architecture established, we now turn to the empirical question: does current macroeconomic data exhibit signals of this irreversible transition? In the following section, we estimate the parameters of the system using historical data and identify which regime—closed, transitional, or exclusionary—the contemporary economy occupies within the modeled phase space.\n\n## Estimating Parameters with Level Data\n\nThe empirical calibration of structural dynamical models often begins with time series data expressed in **absolute levels**. In the context of labor–capital systems, this typically involves tracking population, capital stock, investment flows, and income components—each representing one component of the theoretical system:\n\n$$\n\\begin{aligned}\n\\frac{dL}{dt} &= a_{1,1} L - a_{1,2} L C, \\\\\n\\frac{dC}{dt} &= a_{2,1} L C + a_{2,2} C - a_{2,3} C - a_{2,4} C^2.\n\\end{aligned}\n$$\n\nEach parameter in this system has a corresponding economic interpretation, often approximated using national account statistics or industry-level indicators:\n\n| Parameter       | Interpretation                               | Empirical Proxy                                 |\n|----------------|-----------------------------------------------|--------------------------------------------------|\n| $a_{1,1}$       | Endogenous labor growth                      | Population and participation rates (BLS, UN)     |\n| $a_{1,2}$       | Capital-induced labor absorption             | Wage–productivity divergence, labor share trend  |\n| $a_{2,1}$       | Labor-driven capital formation               | Profit per worker, reinvestment ratios           |\n| $a_{2,2}$       | Automation-induced capital growth            | Robot density, IT capital share, patent counts   |\n| $a_{2,3}$       | Capital depreciation                         | Consumption of fixed capital (BEA, Eurostat)     |\n| $a_{2,4}$       | Frictions to capital expansion               | Diminishing returns, saturation metrics          |\n\nWhile conceptually straightforward, level-based estimation encounters several technical and interpretive challenges. Among these:\n\n- **High sensitivity to measurement errors** in levels, especially when working with small changes (e.g., net investment).\n- **Heterogeneity in units and scaling**, which complicates system-level identification without extensive normalization.\n- **Implicit steady-state assumptions**, particularly when using calibration methods that fix terminal values or target observed ratios (e.g., $C^*/Y^*$ or $K/L$ ratios).\n- **Dependence on aggregation conventions**, such as capital stock estimation or depreciation schedules, which vary significantly across countries and sources.\n\nA variety of empirical strategies have been employed in this context:\n\n- **Closed-form identification**: Parameters like $a_{2,3}$ (capital depreciation) can often be directly observed from national accounts.\n- **Time-series regression**: Parameters such as $a_{2,2}$ (automation growth) or $a_{1,2}$ (labor extraction rate) can be estimated by regressing capital growth or labor share decline on automation-related indicators.\n- **Steady-state calibration**: Assuming long-run convergence, one can calibrate parameters to match terminal or average observed values (e.g., setting $a_{2,4}$ to ensure bounded $C$ given observed capital-output ratios).\n- **Bayesian updating**: Priors from the macroeconomic literature (e.g., Solow-type growth parameters) are updated using observed data.\n- **System-level structural estimation**: Full-model techniques such as GMM or maximum likelihood estimation (MLE) are applied to estimate coupled ODEs from observed $(L_t, C_t)$ time series.\n\nDespite its prevalence, the level-based framework is limited in its ability to track **distributional dynamics** or **relative concentration patterns**, particularly in systems undergoing **structural mutation**. In such cases, absolute levels may grow exponentially while the internal composition of the system changes qualitatively.\n\nTo address these limitations, the next section introduces a **share-based estimation strategy** that reinterprets elite capital concentration data as a proxy for system-level capital dominance, enabling estimation of nonlinear dynamics via normalized replicator-like forms. This approach aligns more naturally with inequality-focused modeling, where relative shares and structural saturation matter more than total quantities.\n\n\n## Estimating Parameters with Share Data\n\nTraditional macroeconomic estimation strategies are typically rooted in level data—aggregate capital stock, total output, labor force levels—used to calibrate dynamic models of production, accumulation, and distribution. While effective in certain contexts, this approach suffers from scaling inconsistencies, comparability issues across time, and sensitivity to nominal shocks. Moreover, level data fails to reveal the **internal stratification** of economic systems—particularly the **distribution of capital** across heterogeneous agents.\n\nTo address this, we introduce a share-based approach. Rather than modeling the absolute size of capital or labor, we model their **relative shares**: \n\n- Capital share: $c(t) = \\frac{C(t)}{C(t) + L(t)}$\n- Labor share: $\\ell(t) = 1 - c(t)$\n\nThis reframing allows us to interpret economic dynamics in terms of **structural positioning** and **relative dominance**, rather than absolute growth. Importantly, this representation is **invariant to total system size**, rendering it more robust for long-term analysis and cross-group comparison.\n\n### U.S. Wealth Share Data (1989–2024, Quarterly)\n\nWe utilize quarterly data from the Federal Reserve's Distributional Financial Accounts (via FRED) to construct empirical capital share trajectories for three elite percentile groups:\n\n- **Top 0.1% Net Wealth Share** (`WFRBSTP1300`)\n- **Top 1% Net Wealth Share** (`WFRBST01134`)\n- **Top 10% Net Wealth Share**, computed as the sum of top 1% and 90–99% (`WFRBSN09161`)\n\nThese series serve as empirical proxies for the **capital share** $c(t)$ held by each group. Corresponding labor shares are then computed as $\\ell(t) = 1 - c(t)$.\n\nThis share-based framing bypasses issues with raw levels (GDP deflators, capital depreciation schedules, labor hours) and instead centers the analysis on **relative control over accumulated wealth**—a key structural feature in capitalist systems.\n\n\n### Share-Based Dynamics\n\nThe structural labor–capital model is given in level terms as:\n\n$$\n\\begin{aligned}\n\\frac{dL}{dt} &= a_{11} L - a_{12} L C, \\\\\n\\frac{dC}{dt} &= a_{21} L C + a_{22} C - a_{23} C - a_{24} C^2.\n\\end{aligned}\n$$\n\nDefine total system size $S(t) = L(t) + C(t)$ and the **capital share**:\n$$\nc(t) = \\frac{C(t)}{S(t)}.\n$$\n\nBy differentiating this definition with respect to time:\n$$\n\\frac{dc}{dt} = \\frac{\\dot{C} S - C \\dot{S}}{S^2}.\n$$\n\nSubstituting the dynamics:\n- $\\dot{C} = a_{21} L C + a_{22} C - a_{23} C - a_{24} C^2$\n- $\\dot{L} = a_{11} L - a_{12} L C$\n- So $\\dot{S} = \\dot{L} + \\dot{C}$\n\nNow let $C = c S$, $L = (1 - c) S$ to express everything in terms of $c(t)$ and $S(t)$.\n\nAssuming $a_{21} \\approx 0$ (negligible labor-driven capital growth) and quasi-stationary $S(t)$ over short windows, the expression simplifies to:\n\n$$\n\\frac{dc}{dt} \\approx c (a_{22} - a_{24} c).\n$$\n\nThis **replicator-type equation** captures the nonlinear interplay between:\n\n- **Self-replicating capital** (via $a_{22}$), and\n- **Intra-elite saturation effects** (via $a_{24}$).\n\nEmpirically, this continuous form becomes:\n$$\n\\frac{\\Delta c_t}{c_t} \\approx a_{22}(t) - a_{24}(t) c_t.\n$$\n\nBy running **rolling-window OLS regressions** (e.g., 20 quarters), we estimate $a_{22}(t)$ and $a_{24}(t)$ as **time-varying structural coefficients**, capturing technological change, financial regime shifts, and institutional transitions.\n\nTo estimate the remaining parameters, we turn to the full coupled system. Normalizing the labor-capital system in share terms:\n\n- For labor:\n$$\n\\frac{\\Delta \\ell_t}{\\ell_t} = a_{11}(t) - a_{12}(t) c_t + \\varepsilon_t.\n$$\n\n- For capital (expanded):\n$$\n\\frac{\\Delta c_t}{c_t} = a_{21}(t) \\ell_t + a_{22}(t) - a_{23}(t) - a_{24}(t) c_t + \\varepsilon_t.\n$$\n\nGiven previously estimated $a_{22}(t)$ and $a_{24}(t)$, and setting $a_{23}(t) = 0.025$ (fixed quarterly depreciation), we identify:\n\n- $a_{11}(t), a_{12}(t)$: from labor-share regression,\n- $a_{21}(t)$: by back-solving from capital equation residuals.\n\n\n### Empirical Findings\n\n1. **$a_{22}(t)$** rises sharply during known automation epochs: dot-com boom, smartphone era, and post-2020 AI expansion.\n2. **$a_{24}(t)$** is consistently positive and increasing with percentile, indicating growing intra-elite competition.\n3. **$a_{21}(t) \\approx 0$ across all groups**, sometimes on the order of $10^{-7}$ or lower.\n\n> This implies that capital is **self-reproducing**, with minimal dependence on labor—a hallmark of late-stage automation economies.\n\nHowever, setting $a_{21} = 0$ creates degenerate dynamics: over time, both capital and labor vanish. Surprisingly, even capital collapses without minimal labor input.\n\nBy setting $a_{21} = 0.0007$ (small but positive), simulations match observed empirical tail behavior in $c(t)$—showing that even **negligible labor-capital coupling** is structurally vital for long-run viability.\n\nThese findings underscore the fragility of modern accumulation systems. The capital-labor system is not sustained by productivity, but by **network-dependent feedback loops**. Small structural parameters—such as $a_{21}$—govern the **existence of long-run attractors**.\n\nPolicy interventions must thus go beyond redistribution. They must alter structural parameters:\n- Lower $a_{12}$ to reduce labor extraction,\n- Cap $a_{24}$ to prevent elite overaccumulation,\n- Increase $a_{21}$ via labor-linked investment,\n- Shift $a_{22}$ toward inclusive automation.\n\nThis model reframes inequality not as an outcome of imbalance, but as a **phase-space feature**—a geometrical consequence of structural dynamics. In summary, share-based empirical modeling reveals structural dependencies invisible in level-data systems. The future of capital depends not on output maximization, but on the topology of feedback and the fragility of replication.\n\n\n## Plots\n\n### US Wealth Share Data\n\n```{python}\n#| label: fig-us-data-load\n#| tbl-cap: \"Quarterly net wealth share data (Top 0.1%, 1%, and 10%) are retrieved directly from the FRED database and used to compute normalized capital share trajectories over the period 1989Q3 to 2024Q4.\"\n\nimport pandas_datareader.data as web\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\nfrom scipy.stats import trim_mean, mode\n\n# Define the time range\nstart_date = \"1989-07-01\"\nend_date = \"2024-10-01\"\n\n# Download data directly for each group\ndata = {}\ndata['Top 0.1%'] = web.DataReader('WFRBSTP1300', 'fred', start_date, end_date)\ndata['Top 1%'] = web.DataReader('WFRBST01134', 'fred', start_date, end_date)\ndata['Top 90-99%'] = web.DataReader('WFRBSN09161', 'fred', start_date, end_date)\n\n# Combine Top 1% and 90-99% to compute Top 10%\ntop_10 = pd.DataFrame(index=data['Top 1%'].index)\ntop_10['Top 10%'] = data['Top 1%']['WFRBST01134'] + data['Top 90-99%']['WFRBSN09161']\n\n# Combine all into a single DataFrame for analysis\ndf = pd.DataFrame(index=data['Top 0.1%'].index)\ndf['Top 0.1%'] = data['Top 0.1%']['WFRBSTP1300']\ndf['Top 1%'] = data['Top 1%']['WFRBST01134']\ndf['Top 10%'] = top_10['Top 10%']\n\ndf = df.dropna()\n\nprint(\"Sample Start: \", start_date)\nprint(\"Sample End: \", end_date)\ndf.head()\n```\n\n### Time-Varying Parameter Estimates (All Groups)\n\n```{python}\n# Time-varying parameter estimation for each wealth share group, using a rolling window regression on the nonlinear replicator-transformed system. Parameters $a_{2,2}(t)$ and $a_{2,4}(t)$ are inferred from capital share growth, while $a_{1,1}(t)$ and $a_{1,2}(t)$ are extracted from labor share contraction. Residual dynamics yield estimates of $a_{2,1}(t)$ and implied $a_{2,3}(t)$.\n\n# Calculate c(t) and l(t) for each group\nct_01 = df['Top 0.1%']\nct_1 = df['Top 1%']\nct_10 = df['Top 10%']\n\nlt_01 = 1 - ct_01\nlt_1 = 1 - ct_1\nlt_10 = 1 - ct_10\n\n# Define a function to compute rolling parameter estimates\ndef estimate_parameters(c_t, window=20, depreciation=0.025):\n    c_t = c_t.dropna()\n    l_t = 1 - c_t\n    dc = c_t.diff()\n    dl = l_t.diff()\n    c_t_lag = c_t.shift(1)\n    l_t_lag = l_t.shift(1)\n    \n    rel_dc = (dc / c_t_lag).dropna()\n    rel_dl = (dl / l_t_lag).dropna()\n\n    df_rolling = pd.DataFrame({\n        'c': c_t_lag,\n        'l': l_t_lag,\n        'dc_rel': rel_dc,\n        'dl_rel': rel_dl\n    }).dropna()\n\n    results = []\n\n    for i in range(window, len(df_rolling)):\n        window_df = df_rolling.iloc[i - window:i]\n        X_c = np.vstack([np.ones(window), -window_df['c']]).T\n        y_c = window_df['dc_rel']\n        a22, a24 = np.linalg.lstsq(X_c, y_c, rcond=None)[0]\n\n        X_l = np.vstack([np.ones(window), -window_df['c']]).T\n        y_l = window_df['dl_rel']\n        a11, a12 = np.linalg.lstsq(X_l, y_l, rcond=None)[0]\n\n        a21_minus_a23 = y_c - (a22 - a24 * window_df['c'])\n        X_a21 = window_df['l']\n        a21 = np.mean(a21_minus_a23 / X_a21)\n        a23 = a21 - depreciation  # using assumed depreciation\n\n        results.append({\n            'date': df_rolling.index[i],\n            'a11': a11,\n            'a12': a12,\n            'a21': a21,\n            'a22': a22,\n            'a23': a23,\n            'a24': a24\n        })\n\n    return pd.DataFrame(results).set_index('date')\n\n# Estimate for all three groups\nres_df_01 = estimate_parameters(ct_01, window=20)\nres_df_1 = estimate_parameters(ct_1, window=20)\nres_df_10 = estimate_parameters(ct_10, window=20)\n```\n\n\n```{python}\n#| label: fig-rolling-params-all\n#| fig-cap: \"Estimated time-varying parameters for each wealth percentile group, based on rolling window regressions. Each panel corresponds to one structural parameter of the labor–capital dynamic system. Differences across percentile groups reflect heterogeneity in structural regimes, such as automation dominance ($a_{2,2}$) or labor extraction intensity ($a_{1,2}$).\"\n\n# 추정 대상 그룹\ngroup_labels = ['Top 0.1%', 'Top 1%', 'Top 10%']\nresults = [res_df_01, res_df_1, res_df_10]\n\n# 파라미터 목록\nparams = ['a11', 'a12', 'a21', 'a22', 'a23', 'a24']\n\n# Plotting\nfig, axes = plt.subplots(3, 2, figsize=(16, 12), sharex=True)\naxes = axes.flatten()\n\nfor i, param in enumerate(params):\n    for group_df, label in zip(results, group_labels):\n        if param in group_df.columns:\n            axes[i].plot(group_df.index, group_df[param], label=label)\n    axes[i].set_title(f\"Parameter: {param}\")\n    axes[i].legend()\n    axes[i].grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n### Distribution of Estimated Parameters (Histogram)\n\n```{python}\n#| label: fig-parameter-histograms\n#| fig-cap: \"Empirical distribution of estimated parameters across Top 0.1%, Top 1%, and Top 10% wealth share groups. Each subplot overlays the histogram of a single parameter's rolling estimates for all three groups. The visual comparison reveals systematic differences in structural dynamics across percentile tiers.\"\n\nimport matplotlib.pyplot as plt\n\n# 추정된 모든 파라미터 리스트\nparameters = ['a11', 'a12', 'a21', 'a22', 'a23', 'a24']\ngroup_dfs = [res_df_01, res_df_1, res_df_10]\ngroup_labels = ['Top 0.1%', 'Top 1%', 'Top 10%']\ncolors = ['tab:blue', 'tab:orange', 'tab:green']\n\nfig, axes = plt.subplots(3, 2, figsize=(14, 10))\naxes = axes.flatten()\n\nfor i, param in enumerate(parameters):\n    ax = axes[i]\n    for df, label, color in zip(group_dfs, group_labels, colors):\n        ax.hist(df[param].dropna(), bins=50, alpha=0.6, label=label, color=color)\n    ax.set_title(f\"Parameter: {param}\")\n    ax.set_xlabel(\"Value\")\n    ax.set_ylabel(\"Frequency\")\n    ax.legend()\n    ax.grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n## Parameter Summary Table: Group-Wise Statistics by Parameter\n\n```{python}\n#| label: tbl-param-summary-wide\n#| tbl-cap: \"Parameter-wise summary statistics across elite groups (Top 0.1%, Top 1%, Top 10%), including median, trimmed mean, and mode for each parameter.\"\n\ndepreciation = 0.025\n\nprint(\"depreciation a23 (quarterly): \", depreciation)\n\nfrom scipy.stats import trim_mean, mode\n\n# Define a function to compute descriptive statistics for each parameter\ndef summarize_parameters(df, name):\n    summary = pd.DataFrame(index=df.columns)\n    summary[\"median\"] = df.median()\n    summary[\"trimmed_mean\"] = df.apply(lambda x: trim_mean(x.dropna(), 0.1))\n    summary[\"mode\"] = df.mode().iloc[0]\n    summary[\"group\"] = name\n    return summary\n\nsummary_01 = summarize_parameters(res_df_01, \"Top 0.1%\")\nsummary_1 = summarize_parameters(res_df_1, \"Top 1%\")\nsummary_10 = summarize_parameters(res_df_10, \"Top 10%\")\n\n# Combine summaries\nparam_summary = pd.concat([summary_01, summary_1, summary_10])\nparam_summary = param_summary.reset_index().rename(columns={\"index\": \"parameter\"})\n\n# Overwrite a23 with constant 0.25 (quarterly) for all groups\nparam_summary.loc[param_summary[\"parameter\"] == \"a23\", [\"median\", \"trimmed_mean\", \"mode\"]] = depreciation\n\n# Extract median values as parameter sets\ndef extract_params(df, group_name, depreciation=0.025):\n    row = df[df[\"group\"] == group_name].set_index(\"parameter\")\n    return {\n        \"a11\": row.loc[\"a11\", \"median\"],\n        \"a12\": row.loc[\"a12\", \"median\"],\n        \"a21\": row.loc[\"a21\", \"median\"],\n        \"a22\": row.loc[\"a22\", \"median\"],\n        \"a23\": depreciation,  # override\n        \"a24\": row.loc[\"a24\", \"median\"]\n    }\n\nparams_top_01 = extract_params(param_summary, \"Top 0.1%\")\nparams_top_1 = extract_params(param_summary, \"Top 1%\")\nparams_top_10 = extract_params(param_summary, \"Top 10%\")\n\n# Define representative median parameters (with calibrated a23 = 0.025)\n\n# 통계량별로 long-form에서 wide-form으로 pivot\npivot_all = param_summary.pivot_table(\n    index=\"parameter\",\n    columns=\"group\",\n    values=[\"median\", \"trimmed_mean\", \"mode\"]\n)\n\n# 열 순서를 보기 좋게 정렬\nordered_columns = [\n    (\"median\", \"Top 0.1%\"), (\"median\", \"Top 1%\"), (\"median\", \"Top 10%\"),\n    (\"trimmed_mean\", \"Top 0.1%\"), (\"trimmed_mean\", \"Top 1%\"), (\"trimmed_mean\", \"Top 10%\"),\n    (\"mode\", \"Top 0.1%\"), (\"mode\", \"Top 1%\"), (\"mode\", \"Top 10%\"),\n]\npivot_all = pivot_all[ordered_columns]\n\n# 소수점 자리수 정리\npivot_all = pivot_all.round(5)\npivot_all\n\n```\n\n## Simulated System Dynamics with Calibrated Labor-Driven Capital Growth ($a_{21} = 0.0007$)\n\n```{python}\n#| label: fig-sim-dynamics-shares\n#| fig-cap: \"Simulated time-domain capital share dynamics $c(t)$ for each percentile group using calibrated $a_{21} = 0.0007$ and median parameter values.\"\n\nfrom scipy.integrate import solve_ivp\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define the system of ODEs with fixed a21 = 0.0007\ndef simulate_system(params, L0=10, C0=3, t_span=(0, 140), t_steps=2000):\n    def system(t, y):\n        L, C = y\n        a11, a12, a21, a22, a23, a24 = (\n            params[\"a11\"], params[\"a12\"], 0.0007,  # fixed!\n            params[\"a22\"], params[\"a23\"], params[\"a24\"]\n        )\n        dLdt = a11 * L - a12 * L * C\n        dCdt = a21 * L * C + a22 * C - a23 * C - a24 * C**2\n        return [dLdt, dCdt]\n\n    t_eval = np.linspace(t_span[0], t_span[1], t_steps)\n    sol = solve_ivp(system, t_span, [L0, C0], t_eval=t_eval)\n    return sol.t, sol.y[0], sol.y[1]\n\n# Simulations for each group\nt, L_01, C_01 = simulate_system(params_top_01)\n_, L_1, C_1 = simulate_system(params_top_1)\n_, L_10, C_10 = simulate_system(params_top_10)\n\n# Normalize to capital share c(t)\nc_01 = C_01 / (L_01 + C_01)\nc_1 = C_1 / (L_1 + C_1)\nc_10 = C_10 / (L_10 + C_10)\n\n# Plot: Capital share over time\nplt.figure(figsize=(12, 5))\nplt.plot(t, c_01, label=\"Top 0.1%\", linewidth=2)\nplt.plot(t, c_1, label=\"Top 1%\", linewidth=2)\nplt.plot(t, c_10, label=\"Top 10%\", linewidth=2)\nplt.title(\"Simulated Capital Share Dynamics by Group ($a_{21} = 0.0007$)\")\nplt.xlabel(\"Time (Quarters)\")\nplt.ylabel(\"Capital Share $c(t)$\")\nplt.ylim(0, 1.05)\nplt.grid(True)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```\n\n\n```{python}\n#| label: fig-phase-space-level\n#| fig-cap: \"Level-Based Phase Space with Vector Field and Simulated Trajectories\"\n# \"Simulated phase trajectories and normalized vector fields in $(L, C)$ space for each percentile group, using calibrated $a_{21} = 0.0007$.\"\n\n# Define simulation function\ndef simulate_system(params, L0=10, C0=3, t_span=(0, 140), t_steps=2000):\n    def system(t, y):\n        L, C = y\n        dLdt = params[\"a11\"] * L - params[\"a12\"] * L * C\n        dCdt = 0.0007 * L * C + params[\"a22\"] * C - params[\"a23\"] * C - params[\"a24\"] * C**2\n        return [dLdt, dCdt]\n    t_eval = np.linspace(t_span[0], t_span[1], t_steps)\n    sol = solve_ivp(system, t_span, [L0, C0], t_eval=t_eval)\n    return sol.t, sol.y[0], sol.y[1]\n\n# Grid for vector field\nL_vals = np.linspace(0, 150, 150)\nC_vals = np.linspace(0, 150, 150)\nL_grid, C_grid = np.meshgrid(L_vals, C_vals)\n\n# Plotting\nfig, axes = plt.subplots(1, 3, figsize=(18, 6))\ngroup_params = {\n    \"Top 0.1%\": params_top_01,\n    \"Top 1%\": params_top_1,\n    \"Top 10%\": params_top_10\n}\n\nfor ax, (label, params) in zip(axes, group_params.items()):\n    # Vector field\n    a11, a12 = params[\"a11\"], params[\"a12\"]\n    a22, a23, a24 = params[\"a22\"], params[\"a23\"], params[\"a24\"]\n    a21 = 0.0007  # fixed\n\n    dL = a11 * L_grid - a12 * L_grid * C_grid\n    dC = a21 * L_grid * C_grid + a22 * C_grid - a23 * C_grid - a24 * C_grid**2\n    mag = np.sqrt(dL**2 + dC**2)\n    dL_norm = dL / (mag + 1e-8)\n    dC_norm = dC / (mag + 1e-8)\n\n    ax.quiver(L_grid, C_grid, dL_norm, dC_norm, angles='xy', color='gray', alpha=0.5)\n\n    # Trajectory\n    t, L_sim, C_sim = simulate_system(params)\n    ax.plot(L_sim, C_sim, 'r-', linewidth=2, label='Trajectory')\n\n    ax.set_title(f\"Phase Space: {label}\")\n    ax.set_xlabel(\"Labor (L)\")\n    ax.set_ylabel(\"Capital (C)\")\n    ax.set_xlim(0, 150)\n    ax.set_ylim(0, 150)\n    ax.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"number-sections":false,"output-file":"d_3_model.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.21","author":"gitSAM","jupyter":"python3","theme":"cosmo","title":"AI시대 동역학 모형","subtitle":"Structural Mutation Model via Automation"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}