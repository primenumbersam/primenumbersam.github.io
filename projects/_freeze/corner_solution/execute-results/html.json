{
  "hash": "e1c6d618df45c33698ff3e5898d20131",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Corner Solutions\nsubtitle: Convex in Optimization Model, but Non-Convex in Reality\nauthor: GitSAM\ndate: '2025-03-10'\nabstract: This notebook explores the corner solution problem in optimization theory, where theoretical convexity contrasts with real-world non-convexities. Through insightful examples, it demonstrates how economic and mathematical assumptions can diverge in practice.\nkeywords: corner solution, optimization, convex, non-convex\nbibliography: corner_solution.bib\nformat:\n  html:\n    code-fold: true\n    toc: true\njupyter: python3\n---\n\n\n### 1. Introduction\n\nIn standard economic theory, both consumer preferences and production sets are generally assumed to exhibit **convexity** [@ArrowDebreu1954; @Debreu1959]. This assumption supports foundational results, including the existence and uniqueness of equilibrium and the efficiency of market allocations. In practice, however, features such as **network externalities** [@KatzShapiro1985; @RochetTirole2003], **rent-seeking** [@ShleiferVishny1993], and **multiple equilibria**—often culminating in pronounced market dominance—can produce outcomes resembling **non-convex preferences** [@Arthur1994]. In many cases, corner solutions and path-dependent equilibria emerge from winner-takes-all dynamics, concentrated economic power, and barriers to entry.\n\n### 2. Convexity in Economic Theory\n\n**2.1 Convex Preferences and Production Sets**\n\n- Consumer preferences are typically modeled with quasi-concave utility functions, yielding convex (or “bowl-shaped”) indifference curves. This setup implies a preference for **diversity** in consumption, rather than extreme or corner solutions [@Debreu1959].\n- Producers are often assumed to face diminishing marginal returns, reflected in a **convex production possibility set**. Under such conditions, output expansions follow a predictable pattern, and average costs rise eventually.\n\n**2.2 Existence and Efficiency of Equilibrium**\n\n- With convexity, free market entry, symmetric information, and price-taking behavior, perfectly competitive markets are shown to possess a **stable equilibrium** that is **Pareto efficient** [@ArrowDebreu1954].\n- These results typically rely on fixed-point theorems and the properties of convex sets, ensuring both the existence of equilibrium prices and (in many cases) uniqueness or stability [@Debreu1959].\n\n**2.3 Normative Implications**\n\n- Convexity underpins the normative stance that, absent significant market failures, competitive markets gravitate toward Pareto-efficient resource allocations.\n- Consequently, government interventions usually aim to correct externalities, public goods issues, or information asymmetries within a broader context of largely convex preferences and production sets.\n\n\n### 3. Non-Convexities in Reality\n\n**3.1 Network Externalities and Increasing Returns to Scale**\n\n- In contrast to diminishing returns, many digital or platform-based markets exhibit **network externalities**, or increasing returns to scale [@KatzShapiro1985; @RochetTirole2003]. As additional users join a platform, its value to each user grows, often driving **corner solutions** in both production and consumption.\n- Instead of smoothly concave utility or production functions, certain markets feature segments of increasing marginal returns, leading to “winner-takes-all” or “winner-take-most” dynamics.\n\n**3.2 Coordination Games and Multiple Equilibria**\n\n- Network externalities commonly create **coordination games**, where each agent’s optimal choice depends on the choices of others. Small initial advantages or random shocks may tip the market toward a specific product or standard, resulting in **lock-in** [@Arthur1994].\n- Such scenarios can produce **multiple Nash equilibria**, for instance everyone choosing Product A or everyone choosing Product B, with potentially large welfare differences between them.\n\n**3.3 Extreme or Corner Solutions in Consumption and Production**\n\n- With robust network effects, consumers or producers may converge on a single brand, platform, or location, effectively marginalizing other options—even if those alternatives might have been preferred under purely convex preferences.\n- These **corner solutions** deviate from the classical idea that diversification in consumption and moderate scales in production yield optimal outcomes.\n\n**3.4 Rent-Seeking and Incumbent Power**\n\n- Dominant firms or groups can exploit **political influence**—through lobbying or regulatory capture—to fortify their positions, reinforcing non-convex outcomes by stifling competition [@Tirole1988; @ShleiferVishny1993].\n- **Rent-seeking** intensifies the misallocation of resources, as efforts are diverted to defending or reinforcing incumbents’ power, often via barriers to entry, reduced competition, and growing inequalities.\n\n### 4. Government Interventions\n\n**4.1 Theoretical View: Correcting Market Imperfections**\n\n- Traditionally, policy interventions focus on addressing market failures, assuming that preferences and technologies remain fundamentally convex and that interventions are limited and transparent.\n\n**4.2 Empirical Evidence: Policy Amplifies Non-Convexities**\n\n- In reality, incumbents can wield outsized influence through **lobbying** and **political capture**, prompting policies that strengthen market concentration [@Tirole1988].\n- Instead of fostering genuinely competitive markets, such policies may lock in non-convex outcomes, creating a **vicious cycle** of entrenched monopolistic power and limited competition.\n\n**4.3 Lock-in and Path Dependence**\n\n- When policy-making aligns with incumbent interests, even minor advantages can become self-reinforcing [@Arthur1994].\n- Consequently, once a market tips toward a specific firm, region, or product, effective competition may prove infeasible without sweeping policy reforms or disruptive innovation.\n\n\n### 5. Conclusion\n\nAlthough classical economic models lean on **convex** preferences and technologies to assert the existence of unique, efficient equilibria, real-world dynamics often revolve around **non-convex** phenomena. Network externalities, coordination failures, and rent-seeking can drive **corner solutions**, multiple equilibria, and **lock-in** that preserve incumbent advantages. Far from mitigating these issues, government policies sometimes exacerbate them through preferential treatment of dominant actors. Recognizing these **non-convex realities** is crucial for crafting policy frameworks that transcend purely theoretical assumptions of convexity and address the path-dependent complexity characterizing modern markets.\n\n### Appendix: Utilitarian Objective function\n\n::: {#6320be23 .cell execution_count=1}\n``` {.python .cell-code}\n#@title Utilitarian objective function\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom scipy.optimize import minimize\n\n# 함수 정의\ndef z_function(x, y, a, b):\n  return y * (x**a) + (1 - y) * ((b - x)**a)\n\n# x, y 범위 및 매개변수 설정\na = 0.3  # 매개변수 a 값 (0과 1 사이)\nb = 20  # 매개변수 b 값\n\nx = np.linspace(0, b, 100)  # x 범위: 0부터 20까지 100개의 점\ny = np.linspace(0, 1, 100)  # y 범위: 0부터 1까지 100개의 점\nX, Y = np.meshgrid(x, y)  # x, y 좌표 격자 생성\n\n\n# Z 값 계산\nZ = z_function(X, Y, a, b)\n\n\ndef negative_z_function(params):\n    x, y = params\n    return -z_function(x, y, a, b)  # 최솟값을 찾기 위해 음수 값 반환\n\n# 초기값 설정 (interior 범위 내)\ninitial_guess = [b / 2, 0.5]\n\n# 경계 조건 설정\nbounds = [(0, b), (0, 1)]\n\n# 최적화 실행\nresult = minimize(negative_z_function, initial_guess, bounds=bounds)\n\n# 결과 추출\nextreme_point_x, extreme_point_y = result.x\nextreme_point_z = z_function(extreme_point_x, extreme_point_y, a, b)\n\nprint(\"Extreme Point (x, y, z):\", extreme_point_x, extreme_point_y, extreme_point_z)\n\n# Calculate Hessian matrix\ndef hessian_matrix(x, y, a, b):\n  \"\"\"Calculates the Hessian matrix of the z_function.\"\"\"\n  d2z_dx2 = a * (a - 1) * (y * (x**(a - 2)) + (1 - y) * ((b - x)**(a - 2)))\n  d2z_dy2 = 0  # Second derivative with respect to y is 0\n  d2z_dxdy = a * (x**(a - 1) - (b - x)**(a - 1))\n  d2z_dydx = d2z_dxdy  # Mixed partial derivatives are equal\n\n  return [[d2z_dx2, d2z_dxdy], [d2z_dydx, d2z_dy2]]\n\n# Determine the type of extreme point\nhessian = hessian_matrix(extreme_point_x, extreme_point_y, a, b)\ndeterminant = np.linalg.det(hessian)\n\nif determinant > 0 and hessian[0][0] > 0:\n  extreme_type = \"Minimum\"\nelif determinant > 0 and hessian[0][0] < 0:\n  extreme_type = \"Maximum\"\nelse:\n  extreme_type = \"Saddle\"\n\nprint(\"Extreme Point Type:\", extreme_type)\n\n\n# 3D 그래프 그리기\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(X, Y, Z)\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('z')\nplt.title('3D Graph of z = y*x^a + (1-y)(b-x)^a')\n\n\n# global interior extreme point 표시\nax.scatter(extreme_point_x, extreme_point_y, extreme_point_z, color='red', marker='o', s=100)\nax.text(extreme_point_x, extreme_point_y, extreme_point_z, f'Extreme Point ({extreme_type})', color='red')\n\nplt.show()\n\n# Contour Plot 그리기\nfig, ax = plt.subplots()\ncontour = ax.contour(X, Y, Z)\nax.set_xlabel('x')\nax.set_ylabel('y')\nplt.title('Contour Plot of z = y*x^a + (1-y)(b-x)^a')\nplt.clabel(contour, inline=1, fontsize=10)\n\n# global interior extreme point 표시\nax.scatter(extreme_point_x, extreme_point_y, color='red', marker='o', s=100)\nax.text(extreme_point_x, extreme_point_y, 'Extreme Point', color='red')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExtreme Point (x, y, z): 10.0 0.5 1.9952623149688795\nExtreme Point Type: Saddle\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](corner_solution_files/figure-html/cell-2-output-2.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](corner_solution_files/figure-html/cell-2-output-3.png){}\n:::\n:::\n\n\n### Appendix: Homogeneous function of degree 1\n\n::: {#94b3e094 .cell execution_count=2}\n``` {.python .cell-code}\n# Define a return to scale\nscale = 1 # Constant return to scale, i.e. Homogeneous function of degree 1\n\n# Define parameter a\na = 1/4\n\n# total wealth of x\nk_x = 2\n# total wealth of y\nk_y = 2\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 경고 메시지 숨기기\nnp.seterr(invalid='ignore')\n\ndef numerical_derivative(f, X, Y, h=1e-5):\n    \"\"\" Compute numerical partial derivatives using central difference method.\"\"\"\n    dfdx = (f(X + h, Y) - f(X - h, Y)) / (2 * h)  # ∂f/∂x\n    dfdy = (f(X, Y + h) - f(X, Y - h)) / (2 * h)  # ∂f/∂y\n    return dfdx, dfdy\n\n# Define functions u_1(x,y) = x^a * y^(1-a) and u_2(x,y) = (2-x)(2-y)\ndef u1(x, y):\n    return x**(scale*a) * y**(scale*(1-a))\n\ndef u2(x, y):\n    return (k_x - x)**(scale*a) * (k_y - y)**(scale*(1-a))\n\n# Define the grid\nx = np.linspace(0, k_x, 15)\ny = np.linspace(0, k_y, 15)\nX, Y = np.meshgrid(x, y)\n\n# Compute the numerical derivatives (vector field components)\nU1, V1 = numerical_derivative(u1, X, Y)\nU2, V2 = numerical_derivative(u2, X, Y)\n\n# Reduce the density of vectors for better visualization\nx_sparse = np.linspace(0, k_x, 8)\ny_sparse = np.linspace(0, k_y, 8)\nX_sparse, Y_sparse = np.meshgrid(x_sparse, y_sparse)\nU1_sparse, V1_sparse = numerical_derivative(u1, X_sparse, Y_sparse)\nU2_sparse, V2_sparse = numerical_derivative(u2, X_sparse, Y_sparse)\n\n# Plot the combined vector fields and contour plots\n#plt.figure(figsize=(8, 8))\n\n# Contour plots of u_1 and u_2 (level curves only)\ncontour1 = plt.contour(X, Y, u1(X, Y), colors='blue', linestyles='solid', linewidths=1)\ncontour2 = plt.contour(X, Y, u2(X, Y), colors='red', linestyles='dashed', linewidths=1)\n\n# Overlay vector fields\nplt.quiver(X_sparse, Y_sparse, U1_sparse, V1_sparse, color='b', angles='xy', label='∇$u_1$')\nplt.quiver(X_sparse, Y_sparse, U2_sparse, V2_sparse, color='r', angles='xy', label='∇$u_2$')\n\n# Labels and grid\nplt.xlabel('x')\nplt.ylabel('y')\nplt.title('Gradient Vector Fields & Level Curves of $u_1$ and $u_2$')\nplt.legend()\nplt.grid('scaled')\nplt.axis('square')\n\nplt.tight_layout()\n# Show the plot\nplt.show()\n\n# Compute the sum of gradients\nU_sum = U1 + U2\nV_sum = V1 + V2\n\n# Reduce the density of vectors for better visualization\nU_sum_sparse, V_sum_sparse = numerical_derivative(lambda x, y: u1(x, y) + u2(x, y), X_sparse, Y_sparse)\n\n# Plot the combined vector fields and contour plots\n#plt.figure(figsize=(8, 8))\n\n# Contour plots of u_1 and u_2 (level curves only)\ncontour1 = plt.contour(X, Y, u1(X, Y), colors='blue', linestyles='solid', linewidths=1)\ncontour2 = plt.contour(X, Y, u2(X, Y), colors='red', linestyles='dashed', linewidths=1)\n\n# Overlay sum of gradient vector fields\nplt.quiver(X_sparse, Y_sparse, U_sum_sparse, V_sum_sparse, color='g', angles='xy', label='∇($u_1 + u_2$)')\n\n# Labels and grid\nplt.xlabel('x')\nplt.ylabel('y')\nplt.title('Sum of Gradient Vector Fields & Level Curves of $u_1$ and $u_2$')\nplt.legend()\n\nplt.grid('scaled')\nplt.axis('square')\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](corner_solution_files/figure-html/cell-3-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](corner_solution_files/figure-html/cell-3-output-2.png){}\n:::\n:::\n\n\n### Appendix: Sigmoid utility function\n\n::: {#a5da5f13 .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# Define constants\nkx = (np.pi**3 / 2) ** (1/3)\nky = (2**(1/2)) * ((np.pi**3 / 2) ** (1/3))\n\n# Define the grid\nx = np.linspace(0, kx, 1000)\ny = np.linspace(0, ky, 1000)\nX, Y = np.meshgrid(x, y)\n\n# Define the functions\nu1 = 1 - np.cos(X**(1/3) * Y**(2/3))\nu2 = 1 - np.cos((kx - X)**(1/3) * (ky - Y)**(2/3))\n\n# Find intersection points where u1 == u2\nthreshold = 1e-3  # Numerical tolerance for equality\nintersection_mask = np.abs(u1 - u2) < threshold\nX_intersect = X[intersection_mask]\nY_intersect = Y[intersection_mask]\nZ_intersect = u1[intersection_mask]  # u1 and u2 are nearly equal\n\n# Create 3D plot\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot intersection line\nax.scatter(X_intersect, Y_intersect, Z_intersect, color='black', s=10, label='Intersection Line')\n\n# Surface plots for reference\nax.plot_surface(X, Y, u1, cmap='Blues', alpha=0.5)\nax.plot_surface(X, Y, u2, cmap='Reds', alpha=0.5)\n\n# Labels and title\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\nax.set_title('3D Intersection of $u_1$ and $u_2$')\nax.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](corner_solution_files/figure-html/cell-4-output-1.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "corner_solution_files"
    ],
    "filters": [],
    "includes": {}
  }
}